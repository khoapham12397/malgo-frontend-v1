<div id="wiki-content">
<h1 class="pt-4">Thuật toán phân tách trọng tâm - Centroid decomposition</h1>
<div class="breadcrumb"><nav aria-label="Breadcrumb"><ol>
<li class="breadcrumb-item"><a href="https://vnoi.info/wiki/gollum/overview/algo/">algo</a></li>
<li class="breadcrumb-item"><a href="https://vnoi.info/wiki/gollum/overview/algo/graph-theory/">graph-theory</a></li>
</ol></nav></div>
<div class>
<div id="wiki-body" class="gollum-markdown-content overflow-hidden ">
<div class="markdown-body ">
<p><strong>Tác giả:</strong></p>
<ul>
<li>Cao Thanh Hậu - Trường đại học Khoa học Tự Nhiên - ĐHQG-HCM</li>
</ul>
<p><strong>Reviewer:</strong></p>
<ul>
<li>Lê Minh Hoàng - Đại học Khoa học Tự nhiên - ĐHQG-HCM</li>
<li>Hồ Ngọc Vĩnh Phát - Đại học Khoa học Tự nhiên - ĐHQG-HCM</li>
<li>Ngô Nhật Quang - Trường THPT chuyên Khoa học Tự Nhiên - ĐHQGHN</li>
</ul>
<p></p><div class="toc"><div class="toc-title">Table of Contents</div><ul><li><a href="#giới-thiệu">Giới thiệu</a></li><li><a href="#trọng-tâm-của-cây">Trọng tâm của cây</a><ul><li><a href="#định-nghĩa">Định nghĩa</a></li><li><a href="#trọng-tâm-của-cây-có-thể-không-độc-nhất">Trọng tâm của cây có thể không độc nhất</a></li><li><a href="#tìm-trọng-tâm-của-cây">Tìm trọng tâm của cây</a></li></ul></li><li><a href="#thuật-toán-phân-tách-trọng-tâm-centroid-decomposition">Thuật toán phân tách trọng tâm - Centroid decomposition</a><ul><li><a href="#bài-toán">Bài toán</a></li><li><a href="#phân-tích">Phân tích</a></li><li><a href="#thuật-toán">Thuật toán</a></li><li><a href="#giải-thích">Giải thích</a></li><li><a href="#cài-đặt">Cài đặt</a></li><li><a href="#mở-rộng">Mở rộng</a></li></ul></li><li><a href="#cây-trọng-tâm">Cây trọng tâm</a></li><li><a href="#áp-dụng">Áp dụng</a><ul><li><a href="#lampice-coci-2019-2020">Lampice - COCI 2019/2020</a><ul><li><a href="#tóm-tắt-đề-bài">Tóm tắt đề bài</a></li><li><a href="#phân-tích-1">Phân tích</a></li><li><a href="#cài-đặt-1">Cài đặt</a></li></ul></li><li><a href="#qtree5">QTREE5</a><ul><li><a href="#tóm-tắt-đề-bài-1">Tóm tắt đề bài</a></li><li><a href="#phân-tích-2">Phân tích</a></li><li><a href="#cài-đặt-2">Cài đặt</a></li></ul></li></ul></li><li><a href="#luyện-tập">Luyện tập</a></li></ul></div>
<h1 class="editable"><a class="anchor" id="giới-thiệu" href="#giới-thiệu"></a>Giới thiệu</h1>
<p>Thuật toán phân tách trọng tâm có thể hiểu là thuật toán "chia để trị" trên cây. Thuật toán này hoạt động bằng cách liên tục chia nhỏ cây và xử lý trên mỗi cây được chia.</p>
<h1 class="editable"><a class="anchor" id="trọng-tâm-của-cây" href="#trọng-tâm-của-cây"></a>Trọng tâm của cây</h1>
<h2 class="editable"><a class="anchor" id="định-nghĩa" href="#định-nghĩa"></a>Định nghĩa</h2>
<p>Trọng tâm của cây - centroid - là một đỉnh trên cây mà khi bỏ nó ra khỏi cây, mỗi thành phần liên thông còn lại có số đỉnh không quá một nửa số đỉnh của cây ban đầu.</p>
<center>
<img src="https://vnoi.info/wiki/uploads/centroid-decomposition_img1.png" width="300px" />
</center>
<p>Cây trong hình trên có trọng tâm là đỉnh $5$.</p>
<h2 class="editable"><a class="anchor" id="trọng-tâm-của-cây-có-thể-không-độc-nhất" href="#trọng-tâm-của-cây-có-thể-không-độc-nhất"></a>Trọng tâm của cây có thể không độc nhất</h2>
<p>Trong một số trường hợp, cây có thể có $2$ trọng tâm, và khi đó $2$ trọng tâm của cây sẽ kề nhau. Tuy nhiên, điều này không làm ảnh hưởng đến các thuật toán được nêu trong bài.</p>
<h2 class="editable"><a class="anchor" id="tìm-trọng-tâm-của-cây" href="#tìm-trọng-tâm-của-cây"></a>Tìm trọng tâm của cây</h2>
<p>Từ định nghĩa, ta có ý tưởng cơ bản để tìm trọng tâm của cây như sau: giả sử trọng tâm của cây chắc chắn thuộc cây con gốc $u$, với mọi đỉnh $v$ là con trực tiếp của $u$, nếu cây con gốc $v$ có nhiều hơn $n/2$ đỉnh thì trọng tâm của cây chắc chắn thuộc cây con gốc $v$. Nếu không tìm được đỉnh $v$ nào thỏa mãn thì $u$ chính là trọng tâm của cây. Trong đó, $n$ là số đỉnh của cây.</p>
<p>Mở rộng ý tưởng, cần xây dựng hàm $findCentroid(u)$ với ý nghĩa: $findCentroid(u)$ được gọi chỉ khi trọng tâm cây chắc chắn thuộc cây con gốc $u$, và giá trị trả về của hàm luôn là trọng tâm của cây. Bên trong hàm này thực hiện tìm $v$ như ý tưởng cơ bản. Nếu tìm được $v$, trả về $findCentroid(v)$, nếu không tìm được thì trả về $u$.</p>
<p>Sau đây là code ví dụ, lưu ý trước khi tìm trọng tâm, ta cần gọi hàm $countChild(root, 0)$ để đếm số lượng đỉnh thuộc từng cây con. Để tìm centroid, gọi $findCentroid(root, 0)$, với $root$ là gốc của cây (có thể chọn bất cứ đỉnh nào).</p>
<pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>           <span class="c1">// n là số đỉnh của cây ban đầu</span>
<span class="kt">int</span> <span class="n">child</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>   <span class="c1">// child[u] là số đỉnh thuộc cây con gốc u</span>

<span class="kt">void</span> <span class="nf">countChild</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">child</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// cây con gốc u có ít nhất 1 đỉnh là đỉnh u</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// với mọi v kề u</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// nếu v là con của u</span>
            <span class="n">countChild</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
            <span class="n">child</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+=</span> <span class="n">child</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">findCentroid</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span> 
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">)</span> <span class="p">{</span> 
            <span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// tìm được v thỏa mãn</span>
                <span class="k">return</span> <span class="n">findCentroid</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">;</span> <span class="c1">// không có giá trị v nào thỏa mãn, trả về u</span>
<span class="p">}</span></code></pre>
<p>Code trên hoạt động với độ phức tạp là $O(n)$ (lưu ý, $n$ là số đỉnh của cây <strong>đang xét</strong>).</p>
<p>Từ định nghĩa hàm $findCentroid(u)$ cũng có thể chứng minh trọng tâm của cây luôn tồn tại. Khi $findCentroid()$ dừng lại tại đỉnh $u$ ($findCentroid(u)$ trả về $u$) ta biết rằng các cây con có gốc là con của $u$ đều đã thỏa mãn điều kiện có số đỉnh không vượt quá $n / 2$. Đồng thời khi $findCentroid(u)$ được gọi ta cũng biết số lượng đỉnh thuộc cây con gốc $u$ không nhỏ hơn $n / 2$, vậy số lượng đỉnh không thuộc cây con gốc $u$ cũng không vượt quá $n / 2$. Vậy khi xóa đỉnh $u$ đi thì mọi cây tạo thành đều có số đỉnh không vượt quá $n/2$.</p>
<h1 class="editable"><a class="anchor" id="thuật-toán-phân-tách-trọng-tâm-centroid-decomposition" href="#thuật-toán-phân-tách-trọng-tâm-centroid-decomposition"></a>Thuật toán phân tách trọng tâm - Centroid decomposition</h1>
<h2 class="editable"><a class="anchor" id="bài-toán" href="#bài-toán"></a>Bài toán</h2>
<p>Ta sẽ cùng giải quyết một bài toán điển hình như sau: Cho một cây có $n$ đỉnh, đếm số đường đi trên cây có độ dài $k$.</p>
<h2 class="editable"><a class="anchor" id="phân-tích" href="#phân-tích"></a>Phân tích</h2>
<p>Nếu thêm điều kiện để bài toán trở thành "Đếm số đường đi trên cây độ dài $k$ đi qua một đỉnh cho trước" thì vấn đề đơn giản hơn khá nhiều.</p>
<p>Để giải quyết bài toán với điều kiện đi qua một đỉnh cho trước, ta chỉ cần chọn đỉnh đó là gốc, lúc này, với mỗi đỉnh $v$ là con trực tiếp của đỉnh gốc, mỗi đỉnh thuộc cây con gốc $v$ có khoảng cách đến gốc là $d$ có thể ghép với tất cả các đỉnh không thuộc cây con gốc $v$ và có khoảng cách đến gốc là $k - d$ để tạo thành một đường đi độ dài $k$ đi qua đỉnh gốc.</p>
<p>Có thể dfs để xây dựng các mảng đếm số lượng đỉnh có khoảng cách đến gốc là $0, 1, 2, 3,…$ trên cây và trong mỗi cây con gốc $v$, khi đó dễ dàng tính được số lượng đường đi thỏa mãn. Độ phức tạp của cách làm này là $O(n)$, với $n$ là số đỉnh của cây đang xét.</p>
<p>Trở lại bài toán ban đầu, làm sao để chuyển từ "số lượng đường đi chứa một đỉnh cố định" thành "số lượng đường đi trên cây"? Khi chọn một đỉnh làm gốc, thấy rằng mọi đường đi trên cây có thể chia thành 2 nhóm: đi qua đỉnh gốc và không đi qua đỉnh gốc. Từ đây ta có ý tưởng như sau: sau mỗi lần đếm số đường đi thỏa mãn đi qua một đỉnh cố định, ta xóa đỉnh đó đi, với mỗi cây mới tạo thành, ta lại thực hiện việc đếm như trên rồi lại xóa đỉnh đi, đến khi mọi đỉnh đều bị xóa.</p>
<p>Cách làm trên cho kết quả chính xác, vì mọi đường đi trên cây đều được xét qua và mỗi đường đi trên cây được xét qua đúng một lần (sau lần đầu tiên, một trong hai đầu mút của đường đi bị xóa hoặc sẽ thuộc về hai cây mới riêng biệt nhau, vì vậy sẽ không được xét lại lần hai).</p>
<p>Tuy nhiên, cách này có độ phức tạp khá lớn trong một số trường hợp. Ví dụ cây là đường thẳng, ta lại liên tục chọn một đầu mút của cây để làm đỉnh cố định, vậy sau mỗi lần xóa, số đỉnh trên cây chỉ giảm đi $1$, độ phức tạp tổng sẽ là $O(n + (n-1) + (n-2) + (n-3)+…) \approx O(n^2)$.</p>
<h2 class="editable"><a class="anchor" id="thuật-toán" href="#thuật-toán"></a>Thuật toán</h2>
<p>Cũng theo ý tưởng trên, nhưng thuật toán phân tách trọng tâm cho cách chọn đỉnh tối ưu hơn, làm giảm độ phức tạp của thuật toán. Cụ thể, thuật toán hoạt động như sau:</p>
<ol>
<li>Chọn trọng tâm của cây làm <strong>gốc</strong> của cây.</li>
<li>Đếm số lượng đường đi trên cây thỏa mãn yêu cầu và có chứa gốc của cây.</li>
<li>Xóa đỉnh gốc. Nếu trước khi xóa cây có nhiều hơn $1$ đỉnh (khi đó tạo thành một hoặc một số cây riêng biệt khác) thì với mỗi cây mới được tạo, trở lại bước $1$.</li>
</ol>
<p>Độ phức tạp của thuật toán bằng $\log(n)$ nhân cho độ phức tạp của bước $2$. Nếu bước $2$ được thực hiện trong $O(m)$, với $m$ là số đỉnh của cây đang xét lúc đó, thì độ phức tạp tổng sẽ là $O(n \times \log(n))$. Nếu bước $2$ được thực hiện trong $O(m\log(m))$, thì độ phức tạp tổng là $O(n \times \log(n)^2)$.</p>
<h2 class="editable"><a class="anchor" id="giải-thích" href="#giải-thích"></a>Giải thích</h2>
<p>Giả sử ta xếp các cây được xét thành nhiều hàng, bắt đầu từ hàng $0$, mỗi hàng gồm một số cây theo quy luật: hàng $0$ chứa cây ban đầu, hàng thứ $i$ ($i$ từ $1$ trở đi) chứa các cây tạo được từ việc phân tách một cây nào đó ở hàng $i - 1$.</p>
<p>Xếp theo quy luật trên thì tổng kích thước (số đỉnh) của tất cả các cây trên một hàng không vượt quá $n$ (gọi $n$ là số đỉnh của cây ban đầu). Tất cả cây ở hàng thứ $i$ có kích thước không quá một nửa kích thước của cây to nhất ở hàng thứ $i - 1$, hay nói cách khác, mỗi cây ở hàng $i$ có số đỉnh không vượt quá $\frac{n}{2^i}$. Vậy chỉ có thể có nhiều nhất $log(n)$ hàng.</p>
<p>Vậy tổng số đỉnh của tất cả các cây tạo thành từ thuật toán trên không vượt quá $n \times \log(n)$, đây cũng chính là độ phức tạp của thuật toán.</p>
<h2 class="editable"><a class="anchor" id="cài-đặt" href="#cài-đặt"></a>Cài đặt</h2>
<pre class="highlight"><code><span class="cp">#include&lt;bits/stdc++.h&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">200005</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">child</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">del</span><span class="p">[</span><span class="n">N</span><span class="p">];</span> <span class="c1">// del[u] để kiểm tra đỉnh u có bị xóa hay chưa</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">countChild</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">child</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> 
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">del</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span> 
		<span class="n">countChild</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
		<span class="n">child</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+=</span> <span class="n">child</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">centroid</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> 
		<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="n">child</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">del</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
			<span class="k">return</span> <span class="n">centroid</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">updateAns</span><span class="p">(</span><span class="kt">int</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//hàm thực hiện bước 2</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="kt">long</span> <span class="nf">solve</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">countChild</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
	
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">child</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">root</span> <span class="o">=</span> <span class="n">centroid</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="c1">// bước 1</span>
	
	<span class="n">updateAns</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="c1">// bước 2</span>
	
	<span class="n">del</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">root</span><span class="p">])</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">del</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> 
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">solve</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">// bước 3</span>

	<span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">k</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">;</span>
		<span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
		<span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">solve</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<h2 class="editable"><a class="anchor" id="mở-rộng" href="#mở-rộng"></a>Mở rộng</h2>
<p>Bước $2$ là bước quan trọng của thuật toán, có thể kiểm tra xem thuật toán có áp dụng được vào bài toán hay không bằng cách kiểm tra xem bước thứ $2$ có khả thi hay không. Bài toán ở bước $2$ thường đơn giản hơn nhiều so với bài toán ban đầu.</p>
<p>Bạn đọc có thể làm thử bài tập ví dụ tại <a href="https://cses.fi/problemset/task/2080">đây</a></p>
<h1 class="editable"><a class="anchor" id="cây-trọng-tâm" href="#cây-trọng-tâm"></a>Cây trọng tâm</h1>
<p>Cây trọng tâm $T'(V, E')$ của cây $T(V, E)$ có thể được xây dựng như sau:
Thêm vào $E'$ các cạnh nối trọng tâm của $T$ với trọng tâm của mỗi cây mới tạo thành khi xóa trọng tâm của $T$ ra khỏi $T$. Với mỗi cây mới tạo được từ việc xóa trọng tâm, thực hiện lại việc thêm cạnh và xóa đỉnh như vừa nêu, tiếp tục đến khi tất cả các đỉnh đều bị xóa.</p>
<p>Sau khi xóa tất cả đỉnh trong cây $T$, ta đã xây dựng được cây $T'$ gọi là cây trọng tâm của cây $T$ ban đầu.</p>
<center>
<img src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExZmM2NjQyYWYyNGIyNTgyNWRlMTMzMmVmZjVmYjQxZDJiNzRkMTgwMiZlcD12MV9pbnRlcm5hbF9naWZzX2dpZklkJmN0PWc/WNYdDoVhmiZgoNKGld/giphy.gif" />
</center>
<p>Cây trọng tâm có một số tính chất đặc biệt như:</p>
<ul>
<li>Cây có số lượng đỉnh bằng với cây ban đầu.</li>
<li>Độ cao của cây không vượt quá $\log(n)$.</li>
<li>$LCA(u, v)$ trên cây trọng tâm cũng thuộc đường đi từ $u$ đến $v$ trên cây ban đầu.</li>
</ul>
<p>Từ các tính chất đó, ta có một ứng dụng vô cùng quan trọng của cây trọng tâm nói riêng hay thuật toán phân tách trọng tâm nói chung. Ứng dụng như sau:</p>
<p>Giả sử cần tính hàm $f(u, v)$ rất nhiều lần, với $f(u, v)$ là một hàm liên quan đến đường đi $u, v$, nghĩa là ta có thể tính $f(u, v)$ từ $f(u, k)$ và $f(k, v)$ với $k$ là một đỉnh thuộc đường đi $u, v$. Khi đó ta có thể tính trước tất cả các giá trị $f(u, p)$ với $p$ là tổ tiên của $u$ <strong>trên cây trọng tâm</strong>. Theo tính chất thứ $2$ thì chỉ có $n\log(n)$ cặp $(u, p)$, có thể áp dụng thuật phân tách trọng tâm để tìm tất cả các giá trị $f(u, p)$ đó. Vậy với hai đỉnh $u, v$ bất kì, ta có thể tính $f(u, v)$ từ $f(u, LCA_{ct}(u, v))$ và $f(v, LCA_{ct})$, trong đó $LCA_{ct}$ là tổ tiên chung gần nhất của $u$ và $v$ trên cây trọng tâm.</p>
<p>Nói đơn giản, vì độ cao của cây trọng tâm chỉ là $\log(n)$, vậy chỉ có tất cả $n\log(n)$ đường đi thẳng (đường đi từ một đỉnh đến một tổ tiên của đỉnh đó). Do đó, ta có thể tính trước tất cả giá trị của các đường đi có $2$ đầu mút là $2$ đầu của đường đi thẳng, từ đó tính giá trị của mọi đường đi trên cây bằng cách chia đường đi đó thành $2$ đường đi mà mỗi đường đi có $2$ đầu mút là $2$ đầu của một đường đi thẳng trên cây trọng tâm.</p>
<p>Đồng thời, việc tìm tổ tiên chung gần nhất trên cây trọng tâm có độ phức tạp vô cùng nhỏ. Độ phức tạp của thuật tìm $LCA$ là $\log(H)$ với $H$ là độ cao của cây. Với cây trọng tâm, $H = \log(n)$, vậy độ phức tạp cho mỗi lần tìm $LCA$ trên cây trọng tâm chỉ là $O(\log(\log(n)))$.</p>
<h1 class="editable"><a class="anchor" id="áp-dụng" href="#áp-dụng"></a>Áp dụng</h1>
<h2 class="editable"><a class="anchor" id="lampice-coci-2019-2020" href="#lampice-coci-2019-2020"></a><a href="https://oj.vnoi.info/problem/coci1920_r3_lampice">Lampice - COCI 2019/2020</a></h2>
<h3 class="editable"><a class="anchor" id="tóm-tắt-đề-bài" href="#tóm-tắt-đề-bài"></a>Tóm tắt đề bài</h3>
<p>Cho một cây có $n$ đỉnh, mỗi đỉnh trên cây mang một kí tự. Tìm độ dài của đường đi dài nhất trên cây mà các kí tự trên đường đi đó tạo thành xâu đối xứng (gọi tắt là đường đi đối xứng).</p>
<h3 class="editable"><a class="anchor" id="phân-tích-1" href="#phân-tích-1"></a>Phân tích</h3>
<p>Thoạt nhìn bài toán giống với các dạng bài dùng thuật phân tách trọng tâm (tìm đường đi thỏa điều kiện…), tuy nhiên bài toán ở bước $2$ là "tìm đường đi đối xứng dài nhất chứa đỉnh gốc" vẫn quá khó để giải quyết.</p>
<p>Vì vậy cần áp dụng thêm thuật toán chặt nhị phân để làm bài toán đơn giản hơn nữa.</p>
<p>Thuật toán chặt nhị phân áp dụng được nhờ tính chất: nếu tồn tại đường đi đối xứng độ dài $k$, thì cũng tồn tại đường đi đối xứng với bất kì độ dài nào nhỏ hơn $k$ và cùng tính chẵn lẻ với $k$ (và vì vậy mà ta cần chặt nhị phân hai lần, một để tìm đường đi đối xứng chẵn dài nhất và một để tìm đường đi đối xứng lẻ dài nhất).</p>
<p>Giải thích đơn giản, nếu tồn tại đường đi đối xứng độ dài $k$, ta có thể bỏ đi hai đầu mút của đường đi để còn lại đường đi độ dài $k - 2$, và vẫn đối xứng.</p>
<p>Khi đã áp dụng chặt nhị phân, bài toán còn lại "liệu có tồn tại đường đi đối xứng độ dài $k$ hay không?"</p>
<p>Bài toán này có thể giải quyết bằng thuật toán phân tách trọng tâm.</p>
<p>Ta cần giải quyết câu hỏi: "có tồn tại đường đi đối xứng độ dài $k$ và chứa đỉnh gốc của cây hay không?".</p>
<p>Câu hỏi có phần tương tự như vấn đề cần giải quyết ở bài tập trước, tuy nhiên có thêm điều kiện "đối xứng".</p>
<p>Gọi $s(u, v)$ là xâu tạo bởi đường đi từ $u$ đến $v$.</p>
<p>Ý tưởng như sau, với $2$ đỉnh $u, v$ mà đường đi từ $u$ đến $v$ có chứa đỉnh gốc và có độ dài là $k$, để kiểm tra xâu đối xứng, ta kiểm tra $s(u, v)$ có bằng $s(v, u)$ hay không, hay kiểm tra $s(u, root_u) + s(root, v) = s(v, root_v) + s(root, u)$ hay không? (gọi $root_u$ là con trực tiếp của $root$ mà là tổ tiên của $u$).</p>
<p>Áp dụng thuật toán $hash$ để kiểm tra, ta cần tìm trước các giá trị $hshdown[u]$, $hshup[u]$ với ý nghĩa lần lượt là hash của $s(root, u)$ và hash của $s(u, root_u)$. Từ các giá trị $hshdown, hshup$ của $u, v$ và các giá trị $k, h$, ta có thể áp dụng và biến đổi phương trình $s(u, root_u) + s(root, v) = s(v, root_v) + s(root, u)$ sao cho mỗi vế độc lập về $u$ hoặc $v$, từ đó giải quyết tương tự như bài tập trước.</p>
<h3 class="editable"><a class="anchor" id="cài-đặt-1" href="#cài-đặt-1"></a>Cài đặt</h3>
<p>Dưới đây là một code đã ac bài Lampice, bạn đọc có thể tham khảo.</p>
<pre class="highlight"><code><span class="cp">#include &lt;bits/stdc++.h&gt;
</span>
<span class="cp">#define For(i, a, b) for (int i=a;i&lt;=b;++i)
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">200005</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">base</span> <span class="o">=</span> <span class="mi">35711</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">mod</span>  <span class="o">=</span> <span class="mf">1e9</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">Len</span><span class="p">,</span> <span class="n">maxDep</span><span class="p">,</span> <span class="n">child</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">valid</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">char</span> <span class="n">a</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">;</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="n">pw</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">countChild</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">child</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">valid</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="n">countChild</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
        <span class="n">child</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+=</span> <span class="n">child</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">hshdown</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">hshup</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;</span> <span class="n">Len</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">hshdown</span> <span class="o">=</span> <span class="p">(</span><span class="n">hshdown</span> <span class="o">*</span> <span class="n">base</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>    
    <span class="n">hshup</span> <span class="o">=</span> <span class="p">(</span><span class="n">hshup</span> <span class="o">+</span> <span class="mi">1LL</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">*</span> <span class="n">pw</span><span class="p">[</span><span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
    
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">x</span> <span class="o">=</span>  <span class="p">(</span><span class="n">hshup</span> <span class="o">*</span> <span class="n">pw</span><span class="p">[</span><span class="n">Len</span> <span class="o">-</span> <span class="n">h</span><span class="p">]</span> <span class="o">-</span> <span class="n">hshdown</span> <span class="o">+</span> <span class="n">mod</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="n">f</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">Len</span> <span class="o">-</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="n">f</span><span class="p">[</span><span class="n">Len</span> <span class="o">-</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">end</span><span class="p">()</span> <span class="p">)</span> 
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">valid</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="n">b</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hshdown</span><span class="p">,</span> <span class="n">hshup</span><span class="p">))</span> 
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">b</span><span class="p">)</span> <span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="p">.</span><span class="n">first</span><span class="p">][</span><span class="n">x</span><span class="p">.</span><span class="n">second</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">maxDep</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxDep</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
    <span class="n">b</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">h</span><span class="p">,</span> <span class="n">x</span><span class="p">});</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">CD</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">countChild</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">half</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">valid</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">child</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">child</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">child</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">half</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="n">childCounting</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="n">For</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxDep</span><span class="p">)</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">maxDep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">valid</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="k">if</span> <span class="p">(</span><span class="n">valid</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">CD</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">child</span><span class="p">[</span><span class="n">v</span><span class="p">]))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">check</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
    <span class="n">For</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="n">valid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">CD</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">solve</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">For</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">For</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">pw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">For</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="n">pw</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pw</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">base</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">check</span><span class="p">(</span><span class="n">g</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="n">l</span> <span class="o">=</span> <span class="n">g</span><span class="p">;</span> <span class="k">else</span> <span class="n">r</span> <span class="o">=</span> <span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    
    <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">check</span><span class="p">(</span><span class="n">g</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span> <span class="n">l</span> <span class="o">=</span> <span class="n">g</span><span class="p">;</span> <span class="k">else</span> <span class="n">r</span> <span class="o">=</span> <span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">r</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span><span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

	<span class="n">solve</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<h2 class="editable"><a class="anchor" id="qtree5" href="#qtree5"></a><a href="https://www.spoj.com/problems/QTREE5">QTREE5</a></h2>
<h3 class="editable"><a class="anchor" id="tóm-tắt-đề-bài-1" href="#tóm-tắt-đề-bài-1"></a>Tóm tắt đề bài</h3>
<p>Cho một cây có $n$ đỉnh, ban đầu mỗi đỉnh đều có màu đen.
Thực hiện $q$ truy vấn, mỗi truy vấn thuộc một trong hai loại sau đây:</p>
<ul>
<li>$0$ $u$: đổi màu đỉnh $u$ (nếu $u$ đang có màu đen thì đổi thành trắng, nếu $u$ có màu trắng thì đổi thành đen).</li>
<li>$1$ $u$: tìm khoảng cách từ đỉnh $u$ đến đỉnh màu trắng gần nhất. Nếu không có đỉnh nào màu trắng, in $-1$.</li>
</ul>
<h3 class="editable"><a class="anchor" id="phân-tích-2" href="#phân-tích-2"></a>Phân tích</h3>
<p>Xây dựng cây trọng tâm của cây được cho, gọi $LCA_{ct}(u, v)$ là tổ tiên chung gần nhất của $u$ và $v$ <strong>trên cây trọng tâm</strong>. Gọi $dist(u, v)$ là khoảng cách giữa đỉnh $u$ và đỉnh $v$ <strong>trên cây ban đầu</strong>.</p>
<p>Khoảng cách giữa $2$ điểm $u$, $v$ bất kì có thể phân tích như sau: $dist(u, v) = dist(u, LCA_{ct}(u, v)) + dist(LCA_{ct}(u, v), v).$ Bằng thuật toán phân tách trọng tâm, ta có thể tính trước mọi giá trị $dist(u, p)$ mà $p$ là tổ tiên của $u$ <strong>trên cây trọng tâm</strong>.</p>
<p>Với mỗi truy vấn, đỉnh $u$ là cố định, ta cần xét qua các đỉnh $v$ màu trắng để tìm $dist(u, v)$ nhỏ nhất. Thấy rằng, có thể có nhiều nhất đến $n$ đỉnh $v$ màu trắng, tuy nhiên chỉ có nhiều nhất $log(n)$ giá trị $LCA_{ct}(u, v)$ khác nhau (tính chất về chiều cao của cây trọng tâm), vì vậy có thể xem xét việc "xử lý chung" cho các đỉnh $v$ mà $LCA_{ct}(u, v)$ cố định.</p>
<p>Với mỗi đỉnh, ta cần $1$ multiset để lưu tất cả các khoảng cách từ đỉnh đó đến một đỉnh <strong>con</strong> màu trắng của nó trên cây trọng tâm, tổng kích thước của các multiset không quá $nlog(n)$. Với mỗi truy vấn đổi màu đỉnh $u$, ta có thể duyệt qua tất cả các đỉnh tổ tiên của $u$ trên cây trọng tâm để cập nhật các multiset cần thiết.</p>
<p>Về truy vấn tìm khoảng cách, ta cũng lại duyệt qua các đỉnh tổ tiên của $u$ trên cây trọng tâm. Tại đỉnh $p$ là tổ tiên của $u$, gọi $s_p$ là khoảng cách nhỏ nhất từ đỉnh $p$ đến một đỉnh màu trắng, ta có $dist(u, p) + s_p$ là độ dài nhỏ nhất của một đường đi từ đỉnh $u$ đến một đỉnh màu trắng và có đi qua $p$, đáp án cho truy vấn là giá trị $dist(u, p) + s_p$ nhỏ nhất khi xét tất cả các đỉnh $p$. Như vậy, bằng cách xét qua hết tất cả các đỉnh $p$ là tổ tiên của $u$ trên cây trọng tâm, ta đã bao quát tất cả các đường đi từ đỉnh $u$ đến một đỉnh trắng nào đó.</p>
<p>Độ phức tạp của thuật toán là $nlog^2(n)$</p>
<p>Lưu ý, giá trị $dist(u, p) + s_p$ đề cập ở trên có thể là giá trị của một đường đi "không chuẩn" - đường đi đi qua một cạnh nhiều lần. Tuy nhiên đường đi này chắc chắn có độ dài lớn hơn đường đi tối ưu, vì vậy ta chỉ cần quan tâm rằng đường đi tối ưu có được xét qua hay không, nếu có, kết quả tìm được là chính xác.</p>
<h3 class="editable"><a class="anchor" id="cài-đặt-2" href="#cài-đặt-2"></a>Cài đặt</h3>
<pre class="highlight"><code><span class="cp">#include &lt;bits/stdc++.h&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mf">1e5</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">oo</span> <span class="o">=</span> <span class="mf">1e9</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">del</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">par</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">child</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="n">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">countChild</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">child</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">p</span> <span class="o">||</span> <span class="n">del</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">child</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+=</span> <span class="n">countChild</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">child</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">centroid</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">p</span> <span class="o">||</span> <span class="n">del</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">m</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> 
            <span class="k">return</span> <span class="n">centroid</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">calcDist</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">p</span> <span class="o">||</span> <span class="n">del</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">root</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">calcDist</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cd</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">countChild</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">centroid</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
    <span class="n">calcDist</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
    <span class="n">del</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">del</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">cd</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="n">par</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">solve</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">root</span> <span class="o">=</span> <span class="n">cd</span><span class="p">();</span>

    <span class="kt">int</span> <span class="n">q</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">col</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">t</span> <span class="o">&gt;&gt;</span> <span class="n">u</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
            <span class="n">col</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">col</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">erase</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">p</span><span class="p">]));</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">p</span><span class="p">]);</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">oo</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
                    <span class="n">ans</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="o">+</span> <span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">begin</span><span class="p">());</span>
                <span class="p">}</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ans</span> <span class="o">&gt;=</span> <span class="n">oo</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"-1</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
            <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ans</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span><span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

    <span class="n">solve</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<h1 class="editable"><a class="anchor" id="luyện-tập" href="#luyện-tập"></a>Luyện tập</h1>
<p><a href="https://cses.fi/problemset/task/2081">Fixed-Length Paths II - CSES</a></p>
<p><a href="https://codeforces.com/contest/715/problem/C">Digit Tree - Codeforces</a></p>
<p><a href="https://oj.uz/problem/view/IOI11_race">Race - IOI2011</a></p>
<p>Bạn đọc cũng có thể tìm thêm bài tập về Centroid tại mục <a href="https://oj.vnoi.info/tags/?tag_id=Centroid">tag</a> trên trang oj.vnoi.info/.</p>
</div>
</div>
</div>
</div>
