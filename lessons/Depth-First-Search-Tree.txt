<div id="wiki-content">
<h1 class="pt-4">Cây DFS (Depth-First Search Tree) và ứng dụng</h1>
<div class="breadcrumb"><nav aria-label="Breadcrumb"><ol>
<li class="breadcrumb-item"><a href="https://vnoi.info/wiki/gollum/overview/algo/">algo</a></li>
<li class="breadcrumb-item"><a href="https://vnoi.info/wiki/gollum/overview/algo/graph-theory/">graph-theory</a></li>
</ol></nav></div>
<div class>
<div id="wiki-body" class="gollum-markdown-content overflow-hidden ">
<div class="markdown-body ">
<p></p><div class="toc"><div class="toc-title">Table of Contents</div><ul><li><a href="#mở-đầu">Mở đầu</a></li><li><a href="#cây-duyệt-chiều-sâu-dfs-cây-dfs">Cây duyệt chiều sâu DFS (cây DFS)</a></li><li><a href="#ứng-dụng-cây-dfs-trong-bài-toán-tìm-khớp-cầu">Ứng dụng cây DFS trong bài toán tìm khớp, cầu</a><ul><li><a href="#định-nghĩa">Định nghĩa</a></li><li><a href="#bài-toán-1">Bài toán 1</a><ul><li><a href="#đề-bài">Đề bài</a></li><li><a href="#phân-tích">Phân tích</a><ul><li><a href="#tìm-cạnh-cầu">Tìm cạnh cầu</a></li><li><a href="#tìm-đỉnh-khớp">Tìm đỉnh khớp</a></li></ul></li><li><a href="#cài-đặt">Cài đặt</a></li><li><a href="#đánh-giá">Đánh giá</a></li></ul></li><li><a href="#bài-toán-2">Bài toán 2</a><ul><li><a href="#đề-bài-1">Đề bài</a></li><li><a href="#phân-tích-1">Phân tích</a><ul><li><a href="#truy-vấn-1">Truy vấn 1</a></li><li><a href="#truy-vấn-2">Truy vấn 2</a></li></ul></li><li><a href="#cài-đặt-1">Cài đặt</a></li><li><a href="#đánh-giá-1">Đánh giá</a></li></ul></li><li><a href="#bài-toán-3">Bài toán 3</a><ul><li><a href="#đề-bài-2">Đề bài</a></li><li><a href="#phân-tích-2">Phân tích</a></li><li><a href="#cài-đặt-2">Cài đặt</a></li><li><a href="#đánh-giá-2">Đánh giá</a></li></ul></li></ul></li><li><a href="#ứng-dụng-cây-dfs-trong-bài-toán-liệt-kê-thành-phần-liên-thông-mạnh">Ứng dụng cây DFS trong bài toán liệt kê thành phần liên thông mạnh</a><ul><li><a href="#định-nghĩa-1">Định nghĩa</a></li><li><a href="#một-số-định-lý-quan-trọng">Một số định lý quan trọng</a></li><li><a href="#bài-toán-4">Bài toán 4</a><ul><li><a href="#đề-bài-3">Đề bài</a></li><li><a href="#thuật-toán-tarjan">Thuật toán Tarjan</a><ul><li><a href="#mô-tả-thuật-toán">Mô tả thuật toán</a></li><li><a href="#ý-tưởng">Ý tưởng</a></li></ul></li><li><a href="#cài-đặt-3">Cài đặt</a></li><li><a href="#đánh-giá-3">Đánh giá</a></li></ul></li><li><a href="#bài-toán-5">Bài toán 5</a><ul><li><a href="#đề-bài-4">Đề bài</a></li><li><a href="#phân-tích-3">Phân tích</a></li><li><a href="#cài-đặt-4">Cài đặt</a></li><li><a href="#đánh-giá-4">Đánh giá</a></li></ul></li></ul></li><li><a href="#bài-tập-vận-dụng">Bài tập vận dụng</a><ul><li><a href="#khớp-cầu">Khớp cầu</a></li><li><a href="#thành-phần-liên-thông-mạnh">Thành phần liên thông mạnh</a></li></ul></li></ul></div>
<p><strong>Tác giả:</strong></p>
<ul>
<li>
<strong>Nguyễn Châu Khanh</strong> - THPT Chuyên Hùng Vương - Phú Thọ</li>
<li>
<strong>Bùi Minh Hoạt</strong> - THPT Chuyên Hùng Vương - Phú Thọ</li>
<li>
<strong>Trần Thế Hưng</strong> - THPT Chuyên Biên Hòa - Hà Nam</li>
</ul>
<p><strong>Reviewer:</strong></p>
<ul>
<li>
<strong>Đỗ Đình Đắc</strong> - Đại học Bách Khoa Hà Nội</li>
</ul>
<h1 class="editable"><a class="anchor" id="mở-đầu" href="#mở-đầu"></a>Mở đầu</h1>
<ul>
<li>Bài viết này sẽ giúp bạn tìm hiểu về cây $DFS$ <em>(Depth First Search Tree – DFS Tree)</em>. Cây $DFS$ là một ứng dụng quan trọng có được từ kỹ thuật duyệt đồ thị ưu tiên chiều sâu, giúp giải các bài toán tìm khớp cầu và thành phần liên thông mạnh.</li>
</ul>
<h1 class="editable"><a class="anchor" id="cây-duyệt-chiều-sâu-dfs-cây-dfs" href="#cây-duyệt-chiều-sâu-dfs-cây-dfs"></a>Cây duyệt chiều sâu DFS (cây DFS)</h1>
<ul>
<li>Trong quá trình $DFS$, với mỗi đỉnh $u$ ta có đỉnh $par[u]$ là số hiệu của đỉnh mà từ đỉnh đó thủ tục $DFS$ gọi đệ quy đến $u$. Xây dựng đồ thị con với các cạnh là $(par[u], u)$ ta có được một cây. Cây này được gọi là <strong>cây <em>DFS</em></strong>.</li>
<li>Các cạnh thuộc cây $DFS$ được gọi là các “cạnh nét liền”.</li>
<li>Các cạnh còn lại không thuộc cây $DFS$ được gọi là các “cạnh nét đứt".</li>
</ul>
<p><img src="https://vnoi.info/wiki/uploads/Depth-First-Search-Tree_img1.png" /></p>
<ul>
<li>Trong đồ thị có hướng, xét các cung được thăm và không được thăm bởi $DFS$, ta có $4$ loại cung sau:
<ul>
<li>Cung của cây $DFS$ <strong><em>(Tree edge)</em></strong>: là các cung thuộc cây $DFS$ được định hướng theo chiều từ cha đến con. (ví dụ cạnh $(u,v)$ thuộc cây $DFS$ mà $u$ được thăm trước $v$ hay $u$ là cha của $v$ thì ta có cung $u \rightarrow v$ là cung của cây $DFS$). <em>$&lt;$ Các cung của cây $DFS$ được đánh dấu là các cạnh màu đen trong hình bên dưới $&gt;$</em>
</li>
<li>Cung xuôi <strong><em>(Forward edge)</em></strong>: là các cung không thuộc cây $DFS$ và có dạng $u \rightarrow v$ trong đó $u$ là tổ tiên của $v$ trong cây $DFS$. <em>$&lt;$ Các cung xuôi được đánh dấu là các cạnh màu xanh lá trong hình bên dưới $&gt;$</em>
</li>
<li>Cung ngược <strong><em>(Back edge)</em></strong>: là các cung không thuộc cây $DFS$ và có dạng $v \rightarrow u$ trong đó $u$ là tổ tiên của $v$ trong cây $DFS$. <em>$&lt;$ Các cung ngược được đánh dấu là các cạnh màu đỏ trong hình bên dưới $&gt;$</em>
</li>
<li>Cung chéo <strong><em>(Cross edge)</em></strong>: là các cung không thuộc cây $DFS$ có dạng $u \rightarrow v$ trong đó $u$ và $v$ thuộc hai nhánh khác nhau của cùng một cây $DFS$. <em>$&lt;$ Các cung chéo được đánh dấu là các cạnh màu xanh dương trong hình bên dưới $&gt;$</em>
</li>
</ul>
<p><img src="https://vnoi.info/wiki/uploads/Depth-First-Search-Tree_img2.png" /></p>
</li>
<li>Trong đồ thị vô hướng:
<ul>
<li>Không tồn tại cung chéo. Vì khi đỉnh $u$ được duyệt trong hàm $DFS$ ta sẽ duyệt tất cả các đỉnh $v$ kề $u$ mà $v$ chưa được thăm. Như vậy nếu tồn tại một cung chéo $(u, v)$ chứng tỏ khi duyệt đến đỉnh $u$ hoặc đỉnh $v$ ta đã không duyệt cạnh $(u, v)$.</li>
<li>Vì các cạnh trên đồ thị vô hướng không được định chiều nên không thể định nghĩa $2$ loại cung xuôi và cung ngược như ở đồ thị có hướng. Do đó, ở đồ thị vô hướng, cung xuôi và cung ngược sẽ được định nghĩa như sau:
<ul>
<li>Cung xuôi <strong><em>(Forward edge)</em></strong>: là các cung thuộc cây $DFS$. Hay còn có cách gọi khác là "cạnh nét liền" hoặc "cung của cây $DFS$".</li>
<li>Cung ngược <strong><em>(Back edge)</em></strong>: là các cung không thuộc cây $DFS$. Hay còn có cách gọi khác là "cạnh nét đứt".</li>
</ul>
</li>
<li>Như vậy trên đồ thị vô hướng lúc này chỉ còn $2$ loại cung là cung ngược và cung xuôi (cung của cây $DFS$).</li>
</ul>
</li>
</ul>
<p><strong>Một số mảng quan trọng trong cây DFS :</strong></p>
<ul>
<li>Mảng $num$[]: cho biết thứ tự duyệt $DFS$ của các đỉnh (thứ tự mà mỗi đỉnh bắt đầu duyệt).</li>
<li>Mảng $low$[]: Với mỗi đỉnh $u$, $low[u]$ cho biết thứ tự (giá trị $num$) nhỏ nhất có thể đi đến được từ $u$ bằng cách đi xuôi xuống theo các cạnh nét liền (các cung trên cây $DFS$) và kết thúc đi ngược lên không quá $1$ lần theo cạnh nét đứt. Ngoài ra ta cũng có thể hiểu ý nghĩa của $low[u]$ là thứ tự thăm của đỉnh có thứ tự thăm sớm nhất nằm trong cây con gốc $u$ hoặc kề cạnh với $1$ đỉnh bất kì nằm trong cây con gốc $u$.</li>
<li>Mảng $tail$[]: cho biết thời điểm kết thúc duyệt $DFS$ của mỗi đỉnh cũng là thời điểm duyệt xong của đỉnh đó .</li>
</ul>
<p><strong>Nhận xét :</strong> Các đỉnh có thứ tự thăm nằm trong khoảng từ $num[u]$ đến $tail[u]$ chính là các đỉnh nằm trong cây con gốc $u$ trong cây $DFS$.</p>
<p><strong>Cách tính mảng low[], num[], tail[] :</strong></p>
<ul>
<li>
<strong>Ý tưởng chính :</strong> Mảng $num[],tail[]$ ta có thể tính dễ dàng bằng cách $DFS$ xác định thời điểm duyệt tới và thời điểm duyệt xong của các đỉnh. Với mảng $low[]$ ta có:
<ul>
<li>Trước hết, với $1$ đỉnh $u$ bất kì có thể tự đi tới chính nó nên ta gán $low[u]=num[u]$.</li>
<li>Từ $u$ có thể đến các đỉnh $v$ kề $u$ bằng $1$ cạnh nét đứt nên ta có $low[u]=min(low[u],num[v])$ với $(u,v)$ là một cạnh nét đứt.</li>
<li>Ngược lại, nếu $(u,v)$ là một cạnh nét liền và $v$ không phải cha $u$ ta có $low[u]=min(low[u],low[v])$ do từ $u$ ta có thể đi xuống $v$ sau đó đi theo con đường đã xác định ở đỉnh $v$ để tới đỉnh có thứ tự thăm là $low[v]$.</li>
</ul>
</li>
<li>
<strong><em>Chú ý</em></strong>: Giá trị thực sự của $num[u]$ được xác định khi duyệt tới đỉnh $u$ còn giá trị thực sự của $low[u],$ $tail[u]$ chỉ được xác định khi đã duyệt xong đỉnh $u$. Thời điểm duyệt tới của một đỉnh $u$ luôn diễn ra trước thời điểm duyệt tới của các đỉnh trong cây con gốc $u$ của cây $DFS$ , thời điểm duyệt xong của đỉnh $u$ luôn diễn ra sau thời điểm duyệt xong của các đỉnh trong cây con gốc $u$.</li>
<li>
<strong>Cách thực hiện :</strong>
<ul>
<li>Đầu tiên ta sẽ bắt đầu duyệt $DFS$ từ đỉnh gốc. Khi duyệt tới đỉnh $u$ ta sẽ cập nhật thời điểm duyệt tới. Lúc này $low[u] = num[u] =$ <strong>thứ tự duyệt <em>DFS</em></strong>. Ta sẽ duyệt tất cả các con $v$ trong gốc $u$.</li>
<li>
<strong>Trường hợp 1:</strong> Nếu đỉnh $v$ chưa được thăm thì sau khi hoàn thành $DFS$ của $v$ thì ta sẽ cập nhật lại giá trị của $low [u]$: $low [u] = min (low[u], low[v]);$</li>
<li>
<strong>Trường hợp 2:</strong> Nếu đỉnh $v$ đã được thăm, thì ta sẽ cập nhật lại giá trị cho $low[u]$: $low [u] = min (low [u], num[v]);$
<ul>
<li>Ở trường hợp này ta không thể cập nhật $low[u] = min(low[u], low[v])$ được. Vì khi ta thăm đến đỉnh $u$ mà đỉnh $v$ đã được thăm thì tức là $(u,v)$ là một cạnh nét đứt, do đó khi đi từ $u$ tới $v$ ta đã sử dụng $1$ cạnh nét đứt nên không thể tiếp tục di chuyển nữa (theo định nghĩa của mảng $low[]$ ) suy ra ta chỉ cập nhật $low[u]=min(low[u],num[v])$.</li>
</ul>
</li>
<li>
<strong>**<em>Chú ý : Nếu v là cha trực tiếp của u thì ta bỏ qua không xét đến.</em></strong>**</li>
<li>Khi đã duyệt xong đỉnh $u$ và các nút trong cây con $DFS$ gốc $u$ ta sẽ tiến hành cập nhật giá trị $tail[u]=$ <strong>thời gian duyệt <em>DFS</em> hiện tại</strong>.</li>
</ul>
</li>
<li><strong>Cài đặt :</strong></li>
</ul>
<pre class="highlight"><code><span class="kt">int</span> <span class="n">timeDfs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Thứ tự duyệt DFS</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pre</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">timeDfs</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">]){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">pre</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
            <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">tail</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">timeDfs</span><span class="p">;</span>
<span class="p">}</span> </code></pre>
<ul>
<li>
<p><strong>Ví dụ minh họa :</strong></p>
<p><img src="https://vnoi.info/wiki/uploads/Depth-First-Search-Tree_img3.png" /></p>
</li>
<li>
<p><strong>Mô tả quá trình :</strong></p>
<p><img src="https://vnoi.info/wiki/uploads/Depth-First-Search-Tree_gif1.gif" /></p>
</li>
</ul>
<h1 class="editable"><a class="anchor" id="ứng-dụng-cây-dfs-trong-bài-toán-tìm-khớp-cầu" href="#ứng-dụng-cây-dfs-trong-bài-toán-tìm-khớp-cầu"></a>Ứng dụng cây DFS trong bài toán tìm khớp, cầu</h1>
<h2 class="editable"><a class="anchor" id="định-nghĩa" href="#định-nghĩa"></a>Định nghĩa</h2>
<ul>
<li>Trong đồ thị vô hướng, một đỉnh được gọi là đỉnh khớp nếu như loại bỏ đỉnh này và các cạnh liên thuộc với nó ra khỏi đồ thị thì số thành phần liên thông của đồ thị tăng lên.</li>
<li>
<p>Trong đồ thị vô hướng, một cạnh được gọi là cạnh cầu nếu như loại bỏ cạnh này ra khỏi đồ thị thì số thành phần liên thông của đồ thị tăng lên.</p>
<p><img src="https://vnoi.info/wiki/uploads/Depth-First-Search-Tree_img4.png" /></p>
</li>
</ul>
<h2 class="editable"><a class="anchor" id="bài-toán-1" href="#bài-toán-1"></a>Bài toán 1</h2>
<p><a href="https://oj.vnoi.info/problem/graph_">GRAPH_ - Tìm khớp và cầu (Cơ bản)</a></p>
<h3 class="editable"><a class="anchor" id="đề-bài" href="#đề-bài"></a><strong>Đề bài</strong></h3>
<p>Xét đơn đồ thị vô hướng $G=(V, E)$ có $N$ $(1 \le N \le 10000)$ đỉnh và $M$ $(1 \le M \le 50000)$ cạnh. Người ta định nghĩa một đỉnh gọi là khớp nếu như xoá đỉnh đó sẽ làm tăng số thành phần liên thông của đồ thị. Tương tự như vậy, một cạnh được gọi là cầu nếu xoá cạnh đó sẽ làm tăng số thành phần liên thông của đồ thị.</p>
<p>Vấn đề đặt ra là cần phải đếm tất cả các khớp và cầu của đồ thị $G$.</p>
<p><strong>Input</strong></p>
<ul>
<li>Dòng đầu: chứa hai số tự nhiên $N, M$.</li>
<li>$M$ dòng sau mỗi dòng chứa một cặp số $(u, v)$ $(u$ khác $v$, $1 \le u \le N, 1 \le v \le N)$ mô tả một cạnh của $G$.</li>
</ul>
<p><strong>Output</strong></p>
<ul>
<li>Gồm một dòng duy nhất ghi hai số, số thứ nhất là số khớp, số thứ hai là số cầu của $G$.</li>
</ul>
<p><strong>Example</strong></p>
<p><strong>Input</strong>
</p><pre class="highlight"><code>10 12
1 10
10 2
10 3
2 4
4 5
5 2
3 6
6 7
7 3
7 8
8 9
9 7</code></pre>
<strong>Output</strong>
<pre class="highlight"><code>4 3</code></pre>
<p><strong>Note</strong></p>
<ul>
<li>Các cạnh màu đỏ là cạnh cầu.</li>
<li>Các đỉnh màu xanh lá là đỉnh khớp.</li>
</ul>
<p><img src="https://vnoi.info/wiki/uploads/Depth-First-Search-Tree_img5.png" /></p>
<h3 class="editable"><a class="anchor" id="phân-tích" href="#phân-tích"></a><strong>Phân tích</strong></h3>
<h4 class="editable"><a class="anchor" id="tìm-cạnh-cầu" href="#tìm-cạnh-cầu"></a><strong>Tìm cạnh cầu</strong></h4>
<ul>
<li>Dễ thấy rằng cạnh cầu của đồ thị không thể là cạnh nét đứt vì việc bỏ đi cạnh nét đứt sẽ không ảnh hưởng đến tính liên thông giữa các đỉnh của đồ thị. Do vậy cạnh cầu chỉ có thể là cạnh nét liền.</li>
<li>Ta sẽ xét riêng từng thành phần liên thông của đồ thị. Xét vùng liên thông $G$ như sau:
<ul>
<li>Xét cây con gốc $v$ trong cây $DFS$ của $G$ có $u$ là cha trực tiếp của $v$. Gọi tập hợp các đỉnh thuộc cây con gốc $v$ là $A$, tập hợp các đỉnh không thuộc cây con gốc $v$ là $B$. Khi xoá đi cạnh $(u, v)$ thì giữa $2$ đỉnh bất kì thuộc cùng $1$ tập hợp vẫn có thể đến với nhau bằng các cạnh nét liền. Một đỉnh thuộc $A$ với một đỉnh thuộc $B$ muốn đi đến với nhau bằng các <strong>cạnh nét liền</strong> thì đều phải thông qua cạnh $(u, v)$.
<ul>
<li>
<strong>Ví dụ minh họa:</strong> Xét cạnh nét liền $(7, 9)$ với đỉnh $9$ là con trực tiếp của đỉnh $7$ trên cây $DFS$. Tập đỉnh $A$ là các đỉnh được đánh dấu màu hồng. Tập đỉnh $B$ là các đỉnh được đánh dấu màu vàng. Đỉnh $11$ thuộc tập $A$ muốn đi đến đỉnh $6$ thuộc tập $B$ bằng các cạnh nét liền thì đều phải thông qua cạnh $(7, 9)$.</li>
</ul>
<p><img src="https://vnoi.info/wiki/uploads/Depth-First-Search-Tree_img6.png" /></p>
</li>
<li>Giả sử không có cạnh nét đứt nào nối giữa $1$ đỉnh thuộc $A$ với $1$ đỉnh thuộc $B$ thì khi xoá cạnh $(u, v)$, $G$ sẽ tách ra thành $2$ vùng liên thông $A$ và $B$. Ngược lại nếu tồn tại cạnh nét đứt nối giữa $1$ đỉnh thuộc $A$ và $1$ đỉnh thuộc $B$ đồ thị vẫn liên thông . Do đó ta chỉ cần xét xem có tồn tại cạnh nét đứt nối giữa $A$ và $B$ hay không để kết luận $(u, v)$ có phải cầu không?</li>
<li>Ta có từ $v$ có thể đi đến một đỉnh $p$ nào đó có $num[p]=low[v]$ bằng cách đi theo các cung của cây $DFS$ và đi qua không quá $1$ cạnh nét đứt và $p$ có thứ tự thăm sớm nhất khi $DFS$. Nếu $p$ nằm trong $B$ thì $p$ phải là tổ tiên của $v$ cũng đồng nghĩa với việc $num[p]&lt;num[v]$ hay $low[v]&lt;num[v]$ <strong>(vì đồ thị không có cung chéo)</strong>, nghĩa là tồn tại $1$ cạnh nét đứt nối giữa $1$ đỉnh thuộc $A$ với $1$ đỉnh thuộc $B$ (vì nếu chỉ đi bằng các cung của cây $DFS$ thì $v$ không thể tới một tổ tiên của nó).</li>
<li>Do đó nếu $low[v] \ge num[v]$ chắc chắn đỉnh $p$ thuộc cây con gốc $v$ hay $p$ thuộc tập hợp $A$ khi đó không tồn tại cạnh nét đứt nối giữa $1$ đỉnh thuộc $A$ với $1$ đỉnh thuộc $B$. Tuy nhiên, ta dễ dàng nhận thấy $low[v] \le num[v]$ vì đỉnh $v$ luôn tới được chính nó.</li>
</ul>
</li>
<li>
<strong>Kết luận:</strong> Nếu $low[v] = num[v]$ thì $(u, v)$ là một cạnh cầu trong đồ thị.</li>
</ul>
<h4 class="editable"><a class="anchor" id="tìm-đỉnh-khớp" href="#tìm-đỉnh-khớp"></a><strong>Tìm đỉnh khớp</strong></h4>
<ul>
<li>Ta sẽ xét riêng từng thành phần liên thông của đồ thị. Xét vùng liên thông $G$ như sau:
<ul>
<li>Xét cây con gốc $u$ trong cây $DFS$ của $G$, nếu mọi nhánh con của $u$ đều có cung ngược lên tới tổ tiên của $u$ ($low[v] &lt; num[u]$, với $v$ là tất cả các con trực tiếp của $u$ trên cây $DFS$) thì đỉnh $u$ không thể là đỉnh khớp. Bởi trong đồ thị ban đầu, nếu ta loại bỏ đỉnh $u$ đi thì từ mỗi đỉnh bất kỳ thuộc nhánh con vẫn có thể đi lên một tổ tiên của $u$, rồi đi sang nhánh con khác hoặc đi sang tất cả những đỉnh còn lại của cây nên số thành phần liên thông của đồ thị không thay đổi.
<ul>
<li>
<strong>Ví dụ minh họa:</strong> Xét đỉnh $9$ không phải là đỉnh khớp vì cả $2$ nhánh con của nó là cây con gốc $10$ và cây con gốc $13$ trong cây $DFS$ đều có cung ngược lên tới đỉnh $7$ là tổ tiên của đỉnh $9$.</li>
</ul>
<p><img src="https://vnoi.info/wiki/uploads/Depth-First-Search-Tree_img7.png" /></p>
</li>
<li>Nếu $u$ không phải là đỉnh gốc của cây $DFS$, và tồn tại ít nhất một nhánh con trong cây con gốc $u$ không có cung ngược lên một tổ tiên của $u$ ($low[v] \ge num[u]$, với $v$ là một con trực tiếp bất kì của $u$ trên cây $DFS$) thì đỉnh $u$ là đỉnh khớp. Bởi khi đó, tất cả những cung xuất phát từ nhánh con đó chỉ có thể đi tới những đỉnh thuộc cây con gốc $u$ mà thôi, trên đồ thị ban đầu, không tồn tại cạnh nối từ những đỉnh thuộc nhánh con đó tới một tổ tiên của $u$. Vậy nên từ một đỉnh bất kì thuộc nhánh con đó muốn đi lên một tổ tiên của $u$ thì bắt buộc phải đi qua $u$ nên việc loại bỏ đỉnh $u$ ra khỏi đồ thị sẽ làm tăng số thành phần liên thông của đồ thị.
<ul>
<li>
<strong>Ví dụ minh họa:</strong> Xét đỉnh $2$ là đỉnh khớp vì tồn tại $1$ nhánh con của nó là cây con gốc $4$ không có cung ngược lên tới tổ tiên của đỉnh $2$.</li>
</ul>
<p><img src="https://vnoi.info/wiki/uploads/Depth-First-Search-Tree_img8.png" /></p>
</li>
<li>Nếu $u$ là đỉnh gốc của cây $DFS$, thì $u$ là đỉnh khớp khi và chỉ khi $u$ có ít nhất $2$ nhánh con. Vì đồ thị không có cung chéo nên khi $u$ có $2$ nhánh con thì đường đi giữa hai đỉnh thuộc hai nhánh con đó bắt buộc phải đi qua $u$. Việc loại bỏ đỉnh $u$ ra khỏi đồ thị sẽ làm tăng số thành phần liên thông của đồ thị.
<ul>
<li>
<strong>Ví dụ minh họa:</strong> Xét đỉnh $1$ là đỉnh khớp vì đỉnh $1$ là đỉnh gốc của cây $DFS$ và có tới $3$ nhánh con.</li>
</ul>
<p><img src="https://vnoi.info/wiki/uploads/Depth-First-Search-Tree_img9.png" /></p>
</li>
</ul>
</li>
<li>
<strong>Kết luận:</strong> Đỉnh $u$ là đỉnh khớp khi:
<ul>
<li>Đỉnh $u$ không phải là gốc của cây $DFS$ và $low[v] \ge num[u]$ (với $v$ là một con trực tiếp bất kì của $u$ trong cây $DFS$).</li>
</ul>
<p><strong>Hoặc</strong></p>
<ul>
<li>Đỉnh $u$ là gốc của cây $DFS$ và có ít nhất $2$ con trực tiếp trong cây $DFS$.</li>
</ul>
</li>
</ul>
<h3 class="editable"><a class="anchor" id="cài-đặt" href="#cài-đặt"></a><strong>Cài đặt</strong></h3>
<p><strong>Cấu trúc dữ liệu:</strong></p>
<ul>
<li>Hằng số <code>maxN = 10010</code>
</li>
<li>Biến <code>timeDfs</code> - Thứ tự $DFS$</li>
<li>Biến <code>bridge</code> - Số lượng cạnh cầu</li>
<li>Mảng <code>low[], num[]</code>
</li>
<li>Mảng <code>joint[]</code> - Đánh dấu đỉnh khớp</li>
<li>Vector <code>g[]</code> - Danh sách cạnh kề của mỗi đỉnh</li>
</ul>
<pre class="highlight"><code><span class="cp">#include &lt;bits/stdc++.h&gt;
</span> 
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
 
<span class="k">const</span> <span class="kt">int</span> <span class="n">maxN</span> <span class="o">=</span> <span class="mi">10010</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">joint</span><span class="p">[</span><span class="n">maxN</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">timeDfs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bridge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">low</span><span class="p">[</span><span class="n">maxN</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">maxN</span><span class="p">];</span>
<span class="n">vector</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">[</span><span class="n">maxN</span><span class="p">];</span>
 
<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pre</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">child</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Số lượng con trực tiếp của đỉnh u trong cây DFS</span>
    <span class="n">num</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">timeDfs</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">pre</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
            <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="n">num</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="n">bridge</span><span class="o">++</span><span class="p">;</span>
            <span class="n">child</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">pre</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Nếu u là đỉnh gốc của cây DFS</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="n">joint</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="n">joint</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> 
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">cntJoint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">cntJoint</span> <span class="o">+=</span> <span class="n">joint</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">cntJoint</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">bridge</span><span class="p">;</span>
<span class="p">}</span> </code></pre>
<h3 class="editable"><a class="anchor" id="đánh-giá" href="#đánh-giá"></a><strong>Đánh giá</strong></h3>
<ul>
<li>Độ phức tạp của bài toán là $O(N + M)$.</li>
</ul>
<h2 class="editable"><a class="anchor" id="bài-toán-2" href="#bài-toán-2"></a>Bài toán 2</h2>
<p><a href="https://oj.vnoi.info/problem/nkpolice">NKPOLICE - Police</a></p>
<h3 class="editable"><a class="anchor" id="đề-bài-1" href="#đề-bài-1"></a><strong>Đề bài</strong></h3>
<p>Để truy bắt tội phạm, cảnh sát xây dựng một hệ thống máy tính mới. Bản đồ khu vực bao gồm $N$ thành phố và $M$ đường nối $2$ chiều. Các thành phố được đánh số từ $1$ đến $N$.</p>
<p>Cảnh sát muốn bắt các tội phạm di chuyển từ thành phố này đến thành phố khác. Các điều tra viên, theo dõi bản đồ, phải xác định vị trí thiết lập trạm gác. Hệ thống máy tính mới phải trả lời được $2$ loại truy vấn sau:</p>
<ul>
<li>$1$. Đối với hai thành phố $A$, $B$ và một đường nối giữa hai thành phố $G1$, $G2$; hỏi tội phạm có thể di chuyển từ $A$ đến $B$ nếu đường nối này bị chặn (nghĩa là tên tội phạm không thể sử dụng con đường này) không?</li>
<li>$2$. Đối với $3$ thành phố $A$, $B$, $C$; hỏi tội phạm có thể di chuyển từ $A$ đến $B$ nếu như toàn bộ thành phố $C$ bị kiểm soát (nghĩa là tên tội phạm không thể đi vào thành phố này) không?</li>
</ul>
<p><strong>Input</strong></p>
<ul>
<li>Dòng đầu tiên chứa $2$ số nguyên $N$ và $M$ $(2 \le N \le 100000, 1 \le M \le 500000)$, số thành phố và số đường nối.</li>
<li>Mỗi dòng trong số $M$ dòng tiếp theo chứa $2$ số nguyên phân biệt thuộc phạm vi $[1, N]$ - cho biết nhãn của hai thành phố nối với nhau bởi một con đường. Giữa hai thành phố có nhiều nhất một đường nối.</li>
<li>Dòng tiếp theo chứa số nguyên $Q$ $(1 \le Q \le 300000)$, số truy vấn được thử nghiệm trên hệ thống.</li>
<li>Mỗi dòng trong $Q$ dòng tiếp theo chứa $4$ hoặc $5$ số nguyên. Số đầu tiên cho biết loại truy vấn $1$ hoặc $2$.
<ul>
<li>Nếu loại truy vấn là $1$, tiếp theo trên cùng dòng là $4$ số nguyên $A$, $B$, $G1$, $G2$ với ý nghĩa như đã mô tả. $A$ khác $B$; $G1$, $G2$ mô tả một con đường có sẵn.</li>
<li>Nếu loại truy vấn là $2$, tiếp theo trên cùng dòng là $3$ số nguyên $A$, $B$, $C$ với ý nghĩa như đã mô tả. $A$, $B$, $C$ đôi một khác nhau.</li>
</ul>
</li>
</ul>
<p>Dữ liệu được cho sao cho ban đầu luôn có cách di chuyển giữa hai thành phố bất kỳ.</p>
<p><strong>Output</strong></p>
<ul>
<li>Gồm $Q$ dòng, mỗi dòng chứa câu trả lời cho một truy vấn. Nếu câu trả lời là khẳng định, in ra "yes". Nếu câu trả lời là phủ định, in ra "no".</li>
</ul>
<p><strong>Example</strong></p>
<p><strong>Input</strong>
</p><pre class="highlight"><code>13 15
1 2
2 3
3 5
2 4
4 6
2 6
1 4
1 7
7 8
7 9
7 10
8 11
8 12
9 12
12 13
5
1 5 13 1 2
1 6 2 1 4
1 13 6 7 8
2 13 6 7
2 13 6 8</code></pre>
<p><strong>Output</strong>
</p><pre class="highlight"><code>yes
yes
yes
no
yes</code></pre>
<p><strong>Note</strong></p>
<p><img src="https://vnoi.info/wiki/uploads/Depth-First-Search-Tree_img10.png" /></p>
<h3 class="editable"><a class="anchor" id="phân-tích-1" href="#phân-tích-1"></a><strong>Phân tích</strong></h3>
<ul>
<li>Để tồn tại ít nhất một cách di chuyển từ thành phố $A$ đến thành phố $B$ thì cả $2$ thành phố $A$ và $B$ phải cùng thuộc một thành phần liên thông.</li>
</ul>
<h4 class="editable"><a class="anchor" id="truy-vấn-1" href="#truy-vấn-1"></a><strong>Truy vấn 1</strong></h4>
<ul>
<li>Dễ thấy rằng, nếu đường nối giữa $2$ thành phố $G1,$ $G2$ không phải là cạnh cầu thì việc loại bỏ nó đi sẽ không ảnh hưởng đến tính liên thông giữa thành phố $A$ và $B$.</li>
<li>Ngược lại, nếu đường nối giữa $2$ thành phố $G1,$ $G2$ là cạnh cầu thì ta phải kiểm tra xem $2$ thành phố $A$ và $B$ có thuộc cùng một thành phần liên thông sau khi loại bỏ cạnh $(G1,G2)$ hay không?</li>
<li>Mỗi khi loại bỏ một cạnh cầu của đồ thị vô hướng thì số thành phần liên thông của đồ thị sẽ tăng thêm $1$. Nghĩa là khi ta loại bỏ cạnh cầu $(G1,G2)$ (với $G2$ là con trực tiếp của $G1$) thì đồ thị sẽ chia ra làm $2$ thành phần liên thông:
<ul>
<li>Thành phần liên thông thứ nhất là tập hợp các đỉnh thuộc cây con gốc $G2$ của cây $DFS$.</li>
<li>Thành phần liên thông thứ nhất là tập hợp các đỉnh còn lại không thuộc cây con gốc $G2$ của cây $DFS$.</li>
</ul>
</li>
<li>
<p><strong>Ví dụ minh họa:</strong> Loại bỏ cạnh cầu $(1,7)$ (với đỉnh $7$ là con trực tiếp của đỉnh $1$)</p>
<p><img src="https://vnoi.info/wiki/uploads/Depth-First-Search-Tree_img11.png" /></p>
</li>
<li>Bây giờ, ta có thể xác định vị trí của $2$ đỉnh $A,$ $B$ có nằm trong cây con gốc $G2$ hay không.
<ul>
<li>Nếu chỉ có đúng duy nhất $1$ trong $2$ đỉnh nằm trong cây con gốc $G2$ thì $2$ thành phố $A$ và $B$ không thuộc cùng một thành phần liên thông sau khi loại bỏ cạnh $(G1,G2)$.</li>
<li>Ngược lại, nếu cả $2$ đỉnh cùng nằm trong cây con gốc $G2$ hoặc cả $2$ đỉnh đều không nằm trong cây con gốc $G2$ thì $2$ thành phố $A$ và $B$ đều thuộc cùng một thành phần liên thông sau khi loại bỏ cạnh $(G1,G2)$.</li>
</ul>
</li>
<li>
<strong>Nhắc lại:</strong> Nếu $num[u] \le num[v] \le tail[u]$ thì đỉnh $v$ nằm trong cây con gốc $u$ của cây $DFS$.</li>
</ul>
<h4 class="editable"><a class="anchor" id="truy-vấn-2" href="#truy-vấn-2"></a><strong>Truy vấn 2</strong></h4>
<ul>
<li>Dễ thấy rằng, nếu thành phố $C$ không phải là đỉnh khớp thì việc loại bỏ nó đi sẽ không ảnh hưởng đến tính liên thông giữa thành phố $A$ và $B$.</li>
<li>Ngược lại, nếu thành phố $C$ là đỉnh khớp thì ta phải kiểm tra xem $2$ thành phố $A$ và $B$ có thuộc cùng một thành phần liên thông sau khi loại bỏ đỉnh $C$ và các cạnh liên thuộc với nó đi hay không?</li>
<li>Vì đồ thị không có cung chéo nên khi loại bỏ đỉnh khớp $C$ ra khỏi đồ thị thì số thành phần liên thông của đồ thị tăng thêm một lượng bằng số lượng đỉnh $v$ là con trực tiếp của $C$ trong cây $DFS$ sao cho không tồn tại cung ngược (cạnh nét đứt) từ một đỉnh thuộc cây con gốc $v$ trong cây $DFS$ nối lên tổ tiên của $C$ (đồng nghĩa với việc $low[v] \ge num[C]$). Nghĩa là khi ta loại bỏ đỉnh khớp $C$ ra khỏi đồ thị thì đồ thị sẽ chia ra làm các thành phần liên thông:
<ul>
<li>Một số thành phân liên thông, mỗi thành phần liên thông là $1$ tập hợp các đỉnh thuộc cây con gốc $v$ với $v$ là con trực tiếp của $C$ trong cây $DFS$ và $low[v] \ge num[C]$.</li>
<li>Một thành phần liên thông là tập hợp tất cả các đỉnh còn lại (bao gồm các đỉnh là tổ tiên của của $C$ và các đỉnh thuộc các cây con gốc $u$ với $u$ là các con trực tiếp của $C$ trong cây $DFS$ và $low[u] &lt; num[C]$).</li>
</ul>
</li>
<li>
<p><strong>Ví dụ minh họa:</strong> Loại bỏ đỉnh khớp $8$. Đỉnh $11$ và $12$ là các con trực tiếp của đỉnh $8$ trong cây $DFS$. Nhưng chỉ có cây con gốc $11$ là tách riêng ra thành $1$ thành phần liên thông riêng biệt. Còn cây con gốc $12$ thì có $1$ cung ngược nối lên đỉnh $7$ (tổ tiên của đỉnh $8$) nên số lượng thành phần liên thông của cả đồ thị chỉ tăng thêm $1$.</p>
<p><img src="https://vnoi.info/wiki/uploads/Depth-First-Search-Tree_img12.png" /></p>
</li>
<li>Với mỗi đỉnh $v$ là con trực tiếp của $C$ trong cây $DFS$ và $low[v] \ge num[C]$, ta kiểm tra xem nếu chỉ có đúng duy nhất $1$ trong $2$ đỉnh nằm trong cây con gốc $v$ thì $2$ thành phố $A$ và $B$ không thuộc cùng một thành phần liên thông sau khi loại bỏ đỉnh $C$ và các cạnh liên thuộc với đỉnh $C$ đi.</li>
<li>Ngược lại, với $v$ là các con trực tiếp của $C$ trong cây $DFS$ và $low[v] \ge num[C]$, nếu cả $2$ đỉnh $A$ và $B$ cùng nằm trong $1$ cây con gốc $v$ hoặc cả $2$ đỉnh $A$ và $B$ đều không nằm trong bất cứ $1$ cây con gốc $v$ nào cả (đồng nghĩa với việc cả $2$ đỉnh $A,$ $B$ sẽ cùng nằm trong thành phần liên thông còn lại) thì $2$ thành phố $A$ và $B$ đều thuộc cùng một thành phần liên thông sau khi loại bỏ đỉnh $C$ và các cạnh liên thuộc với đỉnh $C$ đi.</li>
<li><strong>Tuy nhiên theo thuật toán trên thì với mỗi truy vấn ta sẽ phải duyệt hết tất cả các con trực tiếp của đỉnh <em>C</em> nên khi xử lí các truy vấn sẽ mất độ phức tạp là <em>O(Q⋅ bậc của C)</em>. Trong trường hợp tệ nhất thì đỉnh <em>C</em> có thể lên đến <em>N - 1</em> con trực tiếp <em>(100000 - 1)</em> với số lượng truy vấn <em>Q = 300000</em>, khiến cho thuật toán trên sẽ bị quá thời gian. Bây giờ ta cần phải cải tiến thuật toán :</strong></li>
<li>Thay vì duyệt hết tất cả các con trực tiếp của $C$ để xác định được tổ tiên của $A$, tổ tiên của $B$. Ta có thể sử dụng $Sparse Table$ để tìm ra tổ tiên của đỉnh $A$ (hoặc $B$) là con trực tiếp của đỉnh $C$ nếu $A$ (hoặc $B$) nằm trong cây con $DFS$ gốc $C$.
<strong>Bạn có thể tìm hiểu thêm về <em>Sparse Table</em> và ứng dụng của nó tại <a class="internal absent" href="https://vnoi.info/wiki/translate/topcoder/Range-Minimum-Query-and-Lowest-Common-Ancestor">đây</a></strong>.</li>
<li>Gọi đỉnh $pa$ là tổ tiên của đỉnh $A$ và là con trực tiếp của đỉnh $C$.</li>
<li>Gọi đỉnh $pb$ là tổ tiên của đỉnh $B$ và là con trực tiếp của đỉnh $C$.</li>
<li>$A$ và $B$ thuộc cùng một thành phần liên thông sau khi loại bỏ đỉnh $C$ và các cạnh liên thuộc với đỉnh $C$ đi khi thỏa mãn một trong số các điều kiện sau:
<ul>
<li>Nếu cả $2$ đỉnh $A$ và $B$ đều <strong>không</strong> nằm trong cây con $DFS$ gốc $C$.</li>
<li>Nếu $pa = pb$ (nghĩa là cả $2$ đỉnh $A$ và $B$ đều nằm trong cây con $DFS$ gốc $pa$ ).</li>
<li>Nếu $A$ <strong>không</strong> nằm trong cây con $DFS$ gốc $C$ và $B$ nằm trong cây con $DFS$ gốc $C$ sao cho $low[pb] &lt; num[C]$ (nghĩa là có tồn tại cung ngược nối từ cây con $DFS$ gốc $pb$ lên tổ tiên của $C$ ).</li>
<li>Nếu $B$ <strong>không</strong> nằm trong cây con $DFS$ gốc $C$ và $A$ nằm trong cây con $DFS$ gốc $C$ sao cho $low[pa] &lt; num[C]$ (nghĩa là có tồn tại cung ngược nối từ cây con $DFS$ gốc $pa$ lên tổ tiên của $C$ ).</li>
<li>Nếu cả $2$ đỉnh $A$ và $B$ đều nằm trong cây con $DFS$ gốc $C$ và $low[pa] &lt; num[c]$ và $low[pb] &lt; num[c]$ (nghĩa là cả $2$ cây con $DFS$ gốc $pa$ và cây con $DFS$ gốc $pb$ đều có cung ngược nối lên tổ tiên của $C$ )</li>
</ul>
</li>
<li>Ngược lại, nếu không thỏa mãn tất cả các điều kiện trên thì $A$ và $B$ không thuộc cùng một thành phần liên thông sau khi loại bỏ đỉnh $C$ và các cạnh liên thuộc với đỉnh $C$ đi.</li>
<li>Lúc này, độ phức tạp để xử lí các truy vấn sẽ là $O(Q \cdot logN)$.</li>
</ul>
<h3 class="editable"><a class="anchor" id="cài-đặt-1" href="#cài-đặt-1"></a><strong>Cài đặt</strong></h3>
<p><strong>Cấu trúc dữ liệu:</strong></p>
<ul>
<li>Hằng số <code>maxN = 100010</code>
</li>
<li>Biến <code>timeDfs</code> - Thứ tự $DFS$</li>
<li>Mảng <code>low[], num[], tail[]</code>
</li>
<li>Mảng <code>depth[]</code> - Lưu chiều sâu của mỗi đỉnh trong cây $DFS$</li>
<li>Mảng <code>p[][]</code> - Mảng ứng dụng $Sparse Table$ với $p[i][j]$ là tổ tiên thứ $2^j$ của $i$ trong cây $DFS$</li>
<li>Mảng <code>joint[]</code> - Đánh dấu đỉnh khớp</li>
<li>Vector <code>g[]</code> - Danh sách cạnh kề của mỗi đỉnh</li>
</ul>
<pre class="highlight"><code><span class="cp">#include &lt;bits/stdc++.h&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">maxN</span>  <span class="o">=</span> <span class="mi">100010</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">q</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">timeDfs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">low</span><span class="p">[</span><span class="n">maxN</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">maxN</span><span class="p">],</span> <span class="n">tail</span><span class="p">[</span><span class="n">maxN</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">depth</span><span class="p">[</span><span class="n">maxN</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="n">maxN</span><span class="p">][</span><span class="mi">20</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">joint</span><span class="p">[</span><span class="n">maxN</span><span class="p">];</span>
<span class="n">vector</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">[</span><span class="n">maxN</span><span class="p">];</span>

<span class="cm">/* Tính mảng p */</span>
<span class="kt">void</span> <span class="nf">calP</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">19</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* Tìm tổ tiên của đỉnh u là con trực tiếp của đỉnh par */</span>
<span class="kt">int</span> <span class="nf">findParent</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">par</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">19</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">depth</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">depth</span><span class="p">[</span><span class="n">par</span><span class="p">])</span> <span class="n">u</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Tìm khớp cầu */</span>
<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pre</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">child</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">num</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">timeDfs</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">]){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">pre</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">child</span><span class="o">++</span><span class="p">;</span>
            <span class="n">p</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
            <span class="n">depth</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
            <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">pre</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="n">joint</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="n">joint</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">tail</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">timeDfs</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="cm">/* Kiểm tra xem đỉnh u có nằm trong cây con DFS gốc root hay không? */</span>
<span class="kt">bool</span> <span class="nf">checkInSubtree</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">num</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">num</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">tail</span><span class="p">[</span><span class="n">root</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* Xử lí truy vấn 1 */</span>
<span class="kt">bool</span> <span class="nf">solve1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">g1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">g2</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Vì ta coi g2 là con trực tiếp của g1 nên khi g1 là con của g2, 
    ta phải đổi chỗ 2 giá trị g1 và g2 cho nhau */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">g1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">num</span><span class="p">[</span><span class="n">g2</span><span class="p">])</span> <span class="n">swap</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">);</span> 

    <span class="cm">/* Kiểm tra nếu cạnh (g1, g2) không phải là cầu */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">g2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">num</span><span class="p">[</span><span class="n">g2</span><span class="p">])</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">checkInSubtree</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">g2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">checkInSubtree</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">g2</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">checkInSubtree</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">g2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">checkInSubtree</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">g2</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Xử lí truy vấn 2 */</span>
<span class="kt">bool</span> <span class="nf">solve2</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">joint</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pa</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">checkInSubtree</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="n">pa</span> <span class="o">=</span> <span class="n">findParent</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">checkInSubtree</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="n">pb</span> <span class="o">=</span> <span class="n">findParent</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pa</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pb</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">pa</span> <span class="o">==</span> <span class="n">pb</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> 
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pa</span> <span class="o">&amp;&amp;</span> <span class="n">low</span><span class="p">[</span><span class="n">pb</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> 
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pb</span> <span class="o">&amp;&amp;</span> <span class="n">low</span><span class="p">[</span><span class="n">pa</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pa</span> <span class="o">&amp;&amp;</span> <span class="n">pb</span> <span class="o">&amp;&amp;</span> <span class="n">low</span><span class="p">[</span><span class="n">pa</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">low</span><span class="p">[</span><span class="n">pb</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> 
    <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">depth</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">dfs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">calP</span><span class="p">();</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">type</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">g1</span> <span class="o">&gt;&gt;</span> <span class="n">g2</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">solve1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">)</span> <span class="o">?</span> <span class="s">"yes</span><span class="se">\n</span><span class="s">"</span> <span class="o">:</span> <span class="s">"no</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">c</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">solve2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">?</span> <span class="s">"yes</span><span class="se">\n</span><span class="s">"</span> <span class="o">:</span> <span class="s">"no</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
<h3 class="editable"><a class="anchor" id="đánh-giá-1" href="#đánh-giá-1"></a><strong>Đánh giá</strong></h3>
<ul>
<li>Độ phức tạp của bài toán là $O(N + M + Q \cdot logN)$</li>
</ul>
<h2 class="editable"><a class="anchor" id="bài-toán-3" href="#bài-toán-3"></a>Bài toán 3</h2>
<p><a href="https://oj.vnoi.info/problem/kbuild">KBUILD - Sửa cầu</a></p>
<h3 class="editable"><a class="anchor" id="đề-bài-2" href="#đề-bài-2"></a><strong>Đề bài</strong></h3>
<p>Cho $N$ hòn đảo và $N - 1$ cây cầu, mỗi cây cầu nối hai hòn đảo lại với nhau. Đảm bảo rằng từ một đảo bất kì luôn có thể đến được hết mọi đảo còn lại. Pirate đưa ra một lịch trình như sau: vào mỗi ngày sẽ đi kiểm tra mọi cây cầu trên đường đi từ đảo $a$ đến đảo $b$. Hỏi sau khi Pirate thực hiện xong lịch trình đó, thì còn có bao nhiêu cây cầu chưa được kiểm tra?</p>
<p><strong>Input</strong></p>
<ul>
<li>Dòng thứ nhất: số nguyên $N$ - số lượng hòn đảo.</li>
<li>$N - 1$ dòng tiếp theo: mỗi dòng chứa $2$ số nguyên $a$ và $b$ - có một cây cầu nối đảo $a$ và $b$.</li>
<li>Dòng thứ $N + 1$: Số nguyên $M$ - số ngày kiểm tra.</li>
<li>$M$ dòng tiếp theo: mỗi dòng chứa $2$ số nguyên $a$ và $b$ - ngày hôm đó, Pirate sẽ đi kiểm tra mọi cây cầu trên đường đi từ đảo $a$ đến đảo $b$.</li>
</ul>
<p>$1 \le N, M \le 200000$</p>
<p><strong>Output</strong></p>
<ul>
<li>Một số nguyên duy nhất thể hiện số cây cầu chưa được kiểm tra.</li>
</ul>
<p><strong>Input</strong></p>
<pre class="highlight"><code>6
1 2
2 3
2 4
4 5
4 6
2
3 6
5 6</code></pre>
<p><strong>Output</strong></p>
<pre class="highlight"><code>1</code></pre>
<p><strong>Note</strong></p>
<ul>
<li>Ngày thứ nhất, Pirate kiểm tra các cây cầu $(2, 3), (2, 4)$ và $(4, 6)$. Ngày thứ hai, anh kiểm tra các cây cầu $(5, 4)$ và $(4, 6)$. Cây cầu duy nhất chưa được kiểm tra là $(1, 2)$.</li>
</ul>
<h3 class="editable"><a class="anchor" id="phân-tích-2" href="#phân-tích-2"></a><strong>Phân tích</strong></h3>
<p>Vì đồ thị ban đầu liên thông và có $N - 1$ cạnh nên đây là đồ thị dạng <a href="https://vi.wikipedia.org/wiki/C%C3%A2y_(l%C3%BD_thuy%E1%BA%BFt_%C4%91%E1%BB%93_th%E1%BB%8B)">cây</a>.</p>
<p>Để đánh dấu các cạnh thuộc đường đi từ đỉnh $u$ đến đỉnh $v$ trên cây, thì ta có thể thêm một cạnh $(u,v)$ vào đồ thị. Khi đó, các cạnh thuộc đường đi từ $u \rightarrow v$ trên cây sẽ nằm trong $1$ chu trình. Từ đó, bài toán sẽ quy về thành bài toán đếm số lượng cạnh cầu của đồ thị.</p>
<ul>
<li>
<p><strong>Ví dụ minh họa:</strong> Để dánh dấu đường đi từ đỉnh $3 \rightarrow 6$ và đường đi từ đỉnh $5 \rightarrow 6$, ta thêm cạnh $(3, 6)$, $(5, 6)$ vào đồ thị. Khi đó, đồ thị có một cạnh cầu là cạnh $(1, 2)$.</p>
<p><img src="https://vnoi.info/wiki/uploads/Depth-First-Search-Tree_img13.png" /></p>
</li>
</ul>
<h3 class="editable"><a class="anchor" id="cài-đặt-2" href="#cài-đặt-2"></a><strong>Cài đặt</strong></h3>
<p><strong>Cấu trúc dữ liệu:</strong></p>
<ul>
<li>Hằng số <code>maxN = 200010</code>
</li>
<li>Biến <code>timeDfs</code> - Thứ tự $DFS$</li>
<li>Biến <code>bridge</code> - Số lượng cạnh cầu</li>
<li>Mảng <code>low[], num[]</code>
</li>
<li>Vector <code>g[]</code> - Danh sách cạnh kề của mỗi đỉnh</li>
</ul>
<pre class="highlight"><code><span class="cp">#include &lt;bits/stdc++.h&gt;
</span> 
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
 
<span class="k">const</span> <span class="kt">int</span> <span class="n">maxN</span> <span class="o">=</span> <span class="mf">2e5</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">timeDfs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bridge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">low</span><span class="p">[</span><span class="n">maxN</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">maxN</span><span class="p">];</span>
<span class="n">vector</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">[</span><span class="n">maxN</span><span class="p">];</span>
 
<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pre</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">timeDfs</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">pre</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
            <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="n">num</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="n">bridge</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">g</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
        <span class="n">g</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">m</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">g</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
        <span class="n">g</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">dfs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bridge</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<h3 class="editable"><a class="anchor" id="đánh-giá-2" href="#đánh-giá-2"></a><strong>Đánh giá</strong></h3>
<ul>
<li>Độ phức tạp của bài toán là $O(N + (N - 1 + M))$.</li>
</ul>
<h1 class="editable"><a class="anchor" id="ứng-dụng-cây-dfs-trong-bài-toán-liệt-kê-thành-phần-liên-thông-mạnh" href="#ứng-dụng-cây-dfs-trong-bài-toán-liệt-kê-thành-phần-liên-thông-mạnh"></a>Ứng dụng cây DFS trong bài toán liệt kê thành phần liên thông mạnh</h1>
<h2 class="editable"><a class="anchor" id="định-nghĩa-1" href="#định-nghĩa-1"></a>Định nghĩa</h2>
<ul>
<li>Một đồ thị có hướng là liên thông mạnh nếu như từ một đỉnh bất kì luôn tồn tại ít nhất một đường đi đến bất kì đỉnh nào khác.</li>
<li>Một thành phần liên thông mạnh của một đồ thị có hướng là một đồ thị con tối đại liên thông mạnh. Nếu mỗi thành phần liên thông mạnh được co lại thành một đỉnh, thì đồ thị sẽ trở thành một đồ thị có hướng không có chu trình.</li>
<li>Thuật toán $Kosaraju$, thuật toán $Tarjan$, và thuật toán $Gabow$ đều có thể tìm các thành phần liên thông mạnh của một đồ thị cho trước trong thời gian tuyến tính. Tuy nhiên, các thuật toán của $Tarjan$ thường được sử dụng nhiều hơn do chúng chỉ cần thực hiện tìm kiếm theo chiều sâu một lần trong khi thuật toán của $Kosaraju$ cần hai lần.</li>
</ul>
<p><img src="https://vnoi.info/wiki/uploads/Depth-First-Search-Tree_img14.png" /></p>
<h2 class="editable"><a class="anchor" id="một-số-định-lý-quan-trọng" href="#một-số-định-lý-quan-trọng"></a>Một số định lý quan trọng</h2>
<ul>
<li>
<p><strong>Định lý 1:</strong> Nếu $a$, $b$ là hai đỉnh thuộc thành phần liên thông mạnh $C$ thì với mọi đường đi từ $a$ tới $b$ cũng như từ $b$ tới $a$. Tất cả đỉnh trung gian trên đường đi đó đều phải thuộc $C$.
<strong>Chứng minh:</strong> Nếu $a$ và $b$ là hai đỉnh thuộc $C$ thì tức là có một đường đi từ $a$ đến $b$ và một đường khác đi từ $b$ về $a$. Suy ra với một đỉnh $v$ nằm trên đường đi từ $a$ tới $b$ thì $a$ tới được $v$, $v$ tới được $b$, mà $b$ có đường tới $a$ nên $v$ cũng tới được $a$. Vậy $v$ nằm trong thành phần liên thông mạnh chứa $a$ tức là $v$ thuộc $C$. Tương tự với một đỉnh nằm trên đường đi từ $b$ tới $a$.</p>
</li>
<li>
<p><strong>Định lý 2:</strong> Với một thành phần liên thông mạnh $C$ bất kỳ, tồn tại một đỉnh $r$ thuộc $C$ sao cho mọi đỉnh của $C$ đều thuộc cây con gốc $r$ trong cây $DFS$.
<strong>Chứng minh:</strong> Trước hết, nhắc lại một thành phần liên thông mạnh là một đồ thị con liên thông mạnh của đồ thị ban đầu thoả mãn tính chất <strong>tối đại</strong> tức là việc thêm vào thành phần đó một tập hợp đỉnh khác sẽ làm mắt đi tính liên thông mạnh.</p>
<p>Trong số các đỉnh của $C$, chọn $r$ là đỉnh được thăm đầu tiên theo thuật toán tìm kiếm theo chiều sâu. Ta sẽ chứng minh $C$ nằm trong nhánh $DFS$ gốc $r$. Thật vậy, với một đỉnh $v$ bất kỳ của $C$, do $C$ liên thông mạnh nên phải tồn tại một đường đi từ $r$ tới $v$: $(r = x_0, x_1,…, x_k = v)$</p>
<p>Từ định lý $1$, tất cả các đỉnh $x_1, x_2,…, x_k$ đều thuộc $C$ nên chúng sẽ phải thăm sau đỉnh $r$. Khi thủ tục $DFS(r)$ được gọi thì tất cả các đỉnh $x_1, x_2,…, x_k$ đều chưa thăm; vì thủ tục $DFS(r)$ sẽ liệt kê tất cả những đỉnh chưa thăm đến được từ $r$ bằng cách xây dựng nhánh gốc $r$ của cây $DFS$, nên các đỉnh $x_1, x_2,…, x_k = v$ sẽ thuộc nhánh gốc $r$ của cây $DFS$. Bởi chọn $v$ là đỉnh bất kỳ trong $C$ nên ta có điều phải chứng minh.</p>
<p>Đỉnh $r$ trong chứng minh định lý - đỉnh thăm trước tất cả các đỉnh khác trong $C$ - gọi là chốt của thành phần $C$. Mỗi thành phần liên thông mạnh có duy nhất một chốt. Xét về vị trí trong cây tìm kiếm $DFS$, chốt của một thành phân liên thông là đỉnh nằm cao nhất so với các đỉnh khác thuộc thành phần đó, hay nói cách khác: là tiền bối của tất cả các đỉnh thuộc thành phần đó.</p>
</li>
<li>
<p><strong>Định lý 3:</strong> Luôn tìm được đỉnh chốt $a$ thỏa mãn: Quá trình tìm kiếm theo chiều sâu bắt đầu từ $a$ không thăm được bất kỳ một chốt nào khác. (Tức là nhánh $DFS$ gốc $a$ không chứa một chốt nào ngoài $a$) chẳng hạn ta chọn $a$ là chốt được thăm sau cùng trong một dây chuyền đệ quy hoặc chọn $a$ là chốt thăm sau tất cả các chốt khác. Với chốt $a$ như vậy thì các đỉnh thuộc nhánh $DFS$ gốc $a$ chính là thành phần liên thông mạnh chứa $a$.
<strong>Chứng minh</strong>: Với mọi đỉnh $v$ nằm trong nhánh $DFS$ gốc $a$, xét $b$ là chốt của thành phần liên thông mạnh chứa $v$. Ta sẽ chứng minh $a = b$. Thật vậy, theo định lý $2$, $v$ phải nằm trong nhánh $DFS$ gốc $b$. Vậy $v$ nằm trong cả nhánh $DFS$ gốc $a$ và nhánh $DFS$ gốc $b$. Giả sử phản chứng rằng $a$ khác $b$ thì sẽ có hai trường hợp xảy ra:</p>
<ul>
<li>
<strong>Trường hợp 1:</strong> Nhánh $DFS$ gốc $a$ chứa nhánh $DFS$ gốc $b$, có nghĩa là thủ tục $DFS(b)$ sẽ do thủ tục $DFS(a)$ gọi tới, điều này mâu thuẫn với giả thiết rằng $a$ là chốt mà quá trình tìm kiếm theo chiều sâu bắt đầu từ $a$ không thăm một chốt nào khác.</li>
<li>
<strong>Trường hợp 2:</strong> Nhánh $DFS$ gốc $a$ nằm trong nhánh $DFS$ gốc $b$, có nghĩa là $a$ nằm trên một đường đi từ $b$ tới $v$. Do $b$ và $v$ thuộc cùng một thành phần liên thông mạnh nên theo định lý $1$, $a$ cũng phải thuộc thành phần liên thông mạnh đó. Vậy thì thành phần liên thông mạnh này có hai chốt $a$ và $b$. Điều này vô lý.</li>
</ul>
<p>Theo định lý $2$, ta đã có thành phân liên thông mạnh chứa $a$ nằm trong nhánh $DFS$ gốc $a$, theo chứng minh trên ta lại có: Mọi đỉnh trong nhánh $DFS$ gốc $a$ nằm trong thành phân liên thông mạnh chứa $a$. Kết hợp lại được: Nhánh $DFS$ gốc $a$ chính là thành phần liên thông mạnh chứa $a$.</p>
</li>
</ul>
<h2 class="editable"><a class="anchor" id="bài-toán-4" href="#bài-toán-4"></a>Bài toán 4</h2>
<p><a href="https://oj.vnoi.info/problem/tjalg">TJALG - Tìm TPLT mạnh</a></p>
<h3 class="editable"><a class="anchor" id="đề-bài-3" href="#đề-bài-3"></a><strong>Đề bài</strong></h3>
<p>Cho đồ thị $G(V, E)$ có hướng $N$ $(1 \le N \le 10^4)$ đỉnh, $M$ $(1 \le M \le 10^5)$ cung. Hãy đếm số thành phần liên thông mạnh của $G$.</p>
<p><strong>Input</strong></p>
<ul>
<li>Dòng đầu tiên là $N, M$.</li>
<li>$M$ dòng tiếp theo mô tả một cung của $G$.</li>
</ul>
<p><strong>Output</strong></p>
<ul>
<li>Gồm một dòng duy nhất là số TPLT mạnh.</li>
</ul>
<p><strong>Examples</strong></p>
<p><strong>Input</strong>
</p><pre class="highlight"><code>3 2
1 2
2 3</code></pre>
<p><strong>Output</strong>
</p><pre class="highlight"><code>3</code></pre>
<p><strong>Input</strong>
</p><pre class="highlight"><code>3 3
1 2
2 3
3 1</code></pre>
<p><strong>Output</strong>
</p><pre class="highlight"><code>1</code></pre>
<h3 class="editable"><a class="anchor" id="thuật-toán-tarjan" href="#thuật-toán-tarjan"></a><strong>Thuật toán Tarjan</strong></h3>
<p><img src="https://vnoi.info/wiki/uploads/Depth-First-Search-Tree_img15.png" /></p>
<p><strong>Thuật toán Tarjan được xây dựng dựa trên các dữ kiện sau:</strong></p>
<ul>
<li>Tìm kiếm $DFS$ tạo ra cây/ rừng $DFS$</li>
<li>Các thành phần liên thông mạnh tạo thành các cây con của cây $DFS$.</li>
<li>Nếu ta có thể tìm được đỉnh gốc của các cây con như vậy, ta có thể in/ lưu trữ tất cả các nút trong cây con đó (bao gồm cả đỉnh gốc) và đó sẽ là một thành phần liên thông mạnh $(Strongly$ $Connected$ $Components$ - $SCC).$</li>
<li>Không có cung ngược từ $SCC$ này sang $SCC$ khác (Có thể có các cung chéo, nhưng các cung chéo sẽ không được sử dụng trong khi xử lý đồ thị).</li>
</ul>
<h4 class="editable"><a class="anchor" id="mô-tả-thuật-toán" href="#mô-tả-thuật-toán"></a><strong>Mô tả thuật toán</strong></h4>
<p><img src="https://vnoi.info/wiki/uploads/Depth-First-Search-Tree_gif2.gif" /></p>
<h4 class="editable"><a class="anchor" id="ý-tưởng" href="#ý-tưởng"></a><strong>Ý tưởng</strong></h4>
<ul>
<li>
<strong>Nhận xét:</strong> Xét cây con gốc $u$ trong cây $DFS$. Gọi tập hợp các đỉnh thuộc cây con gốc $u$ là $A$, tập hợp các đỉnh không thuộc cây con gốc $u$ là $B$. Nếu tồn tại $1$ đỉnh $x$ thuộc $A$ tới được $1$ đỉnh $y$ thuộc $B$ thì $y$ phải có thứ tự thăm sớm hơn $u$. Vì nếu $y$ được thăm sau $u$ ta có thể duyệt từ $u$ qua $x$ tới $y$ khi đó $y$ sẽ trở thành con của $u$.</li>
<li>Đầu tiên ta thực hiện $DFS$ kết hợp tính mảng $low[], num[]$ như đã trình bày ở trên. Song song với việc này, khi duyệt tới đỉnh $u$ ta sẽ thực hiện đẩy $u$ vào $stack$.</li>
<li>Khi đã duyệt xong đỉnh $u$ (sau khi duyệt hết toàn bộ các đỉnh nằm trong cây con $DFS$ gốc $u$), nếu $num[u] = low[u]$ thì đây chính là đỉnh có thứ tự thăm sớm nhất của một thành phần liên thông mạnh.</li>
<li>Khi đó ta sẽ loại bỏ tất cả các đỉnh trong thành phần liên thông mạnh này ra khỏi đồ thị và các đỉnh này là các đỉnh đang nằm trên $u$ trong $stack$ hiện tại vì các đỉnh này chính là các đỉnh nằm trên cây con gốc $u$ trong cây $DFS$ do các nút được đẩy vào $stack$ theo thứ tự thăm.</li>
<li>Mặt khác, giả sử ta có đỉnh $x$ thuộc cây con gốc $u$ và $x$ thuộc một thành phần liên thông mạnh không chứa $u$ có đỉnh có thứ tự thăm sớm nhất là $y$, dễ thấy $y$ phải là con của $u$ nên thời điểm duyệt xong của $y$ sớm hơn $u$ chứng tỏ $y$ và thành phần liên thông mạnh chứa nó sẽ bị loại bỏ trước đó không còn trong $stack$ nữa (nếu $y$ không phải con $u$ thì vô lí vì ta đang xét mọi đỉnh trong cây con gốc $u$ chưa được xác định nằm trong thành phần liên thông mạnh nào hiện tại không tới được các đỉnh không nằm trong cây con gốc $u$).</li>
<li>Ta sẽ đánh dấu tất cả các đỉnh thuộc thành phần liên thông mạnh này bằng $1$ mảng để sau này không xét lại đỉnh đấy nữa. Đồng thời, ta loại bỏ cách đỉnh này ra khỏi $stack$ để không làm ảnh hưởng tới các đỉnh khác vẫn còn nằm trong đồ thị.</li>
</ul>
<h3 class="editable"><a class="anchor" id="cài-đặt-3" href="#cài-đặt-3"></a><strong>Cài đặt</strong></h3>
<p><strong>Cấu trúc dữ liệu:</strong></p>
<ul>
<li>Hằng số <code>maxN = 100010</code>
</li>
<li>Biến <code>timeDfs</code> - Thứ tự $DFS$</li>
<li>Biến <code>scc</code> - Số lượng thành phần liên thông mạnh</li>
<li>Mảng <code>low[], num[]</code>
</li>
<li>Mảng <code>deleted[]</code> - Đánh dấu các đỉnh đã bị xóa</li>
<li>Vector <code>g[]</code> - Danh sách cạnh kề của mỗi đỉnh</li>
<li>Ngăn xếp <code>st</code> - Lưu lại các đỉnh trong thành phần liên thông mạnh</li>
</ul>
<pre class="highlight"><code><span class="cp">#include &lt;bits/stdc++.h&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">maxN</span> <span class="o">=</span> <span class="mi">100010</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">timeDfs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">scc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">low</span><span class="p">[</span><span class="n">maxN</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">maxN</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">deleted</span><span class="p">[</span><span class="n">maxN</span><span class="p">];</span>
<span class="n">vector</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">[</span><span class="n">maxN</span><span class="p">];</span>
<span class="n">stack</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">st</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">timeDfs</span><span class="p">;</span>
    <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
    	<span class="k">if</span> <span class="p">(</span><span class="n">deleted</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num</span><span class="p">[</span><span class="n">v</span><span class="p">]){</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
            <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="n">num</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">scc</span><span class="o">++</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">v</span><span class="p">;</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> 
            <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">deleted</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">u</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">scc</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<h3 class="editable"><a class="anchor" id="đánh-giá-3" href="#đánh-giá-3"></a><strong>Đánh giá</strong></h3>
<ul>
<li>Độ phức tạp của thuật toán $Tarjan$ là $O(N + M)$</li>
</ul>
<h2 class="editable"><a class="anchor" id="bài-toán-5" href="#bài-toán-5"></a>Bài toán 5</h2>
<p><a href="https://oj.vnoi.info/problem/kcollect">KCOLLECT - Thu hoạch</a></p>
<h3 class="editable"><a class="anchor" id="đề-bài-4" href="#đề-bài-4"></a><strong>Đề bài</strong></h3>
<p>Khu vườn của Pirate có hình chữ nhật, và được chia thành $M \cdot N$ ô vuông bằng nhau. Trong mỗi ô vuông có một cây thuộc một loại quả khác nhau, đánh số từ $0$ đến $9$. Những con số này thể hiện giá trị kinh tế của các loại cây.
Tuy nhiên, nhìn mặt con Robot trái cây này có vẻ ngu ngu nên trong lần đầu tiên thử việc, Pirate muốn test AI của nó. Cụ thể là Robot phải tuân theo các quy định sau:</p>
<ol>
<li>Tại mỗi ô, Robot chỉ có thể đi sang hướng đông hoặc hướng nam sang ô kề cạnh.</li>
<li>Có một số ô đặc biệt mà tại đó Robot có thể đi được thêm hướng tây hoặc hướng bắc sang ô kề cạnh (chỉ một trong hai).</li>
<li>Robot không được đi vào những ô có cây dừa.</li>
<li>Robot được đi qua một ô nhiều lần. Khi đi qua một ô, Robot phải hái hết quả ở cây trong ô đó. Lợi nhuận thu được sẽ bằng chỉ số của loại cây vừa được thu hái. Và sau này, không thể đạt thêm lợi nhuận gì từ ô đó nữa.</li>
</ol>
<p>Xuất phát từ ô ở góc tây bắc của khu vườn, hãy giúp Robot trái cây xác định hành trình để đạt được lợi nhuận tối đa.</p>
<p><strong>Input</strong></p>
<ul>
<li>Dòng thứ nhất: ghi hai số nguyên $M$ và $N$ - kích thước của khu vườn.</li>
<li>$M$ dòng tiếp theo: mỗi dòng ghi $N$ kí tự liên tiếp nhau mô tả khu vườn:
+ '0' - '9': các loại trái cây;
+ '#': cây dừa;
+ 'W': được quyền đi theo hướng tây;
+ 'N': được quyền đi theo hướng bắc.</li>
</ul>
<p><strong>Output</strong></p>
<ul>
<li>Ghi một số nguyên duy nhất là lợi nhuận tối đa đạt được.</li>
</ul>
<p><strong>Example</strong></p>
<p><strong>Input</strong>
</p><pre class="highlight"><code>2 3
264
3WW</code></pre>
<p><strong>Output</strong>
</p><pre class="highlight"><code>15</code></pre>
<p><strong>Note</strong></p>
<ul>
<li>Robot sẽ đi theo hành trình như sau $(1, 1) \rightarrow (1, 2) \rightarrow (1, 3) \rightarrow (2, 3) \rightarrow (2, 2) \rightarrow (2, 1)$
(ô $(i, j)$ là ô ở dòng $i$ và cột $j$). Tổng lợi nhuận sẽ là $2 + 6 + 4 + 3 = 15$.</li>
</ul>
<h3 class="editable"><a class="anchor" id="phân-tích-3" href="#phân-tích-3"></a><strong>Phân tích</strong></h3>
<ul>
<li>
<strong>Tại sao ta không thể Quy hoạch động ngay được?</strong>
Theo đề bài, ở tại mỗi ô Robot có thể đi sang hướng đông (đi sang phải) hoặc hướng nam (đi xuống dưới) sang ô kề cạnh. Tuy nhiên ở những ô đặc biệt thì Robot có thể đi thêm hướng tây (đi sang trái) hoặc hướng bắc (đi lên trên). Và một ô có thể được Robot đi qua nhiều lần. Chính vì lí do này thế nên cách đi của Robot sẽ tạo thành chu trình. Khi đường đi tạo thành chu trình thì khi ta QHĐ sẽ bị vô hạn.</li>
<li>
<strong>Làm sao để đường đi không tạo thành chu trình?</strong>
Một đồ thị có hướng là <strong>liên thông mạnh</strong> nếu như có đường từ bất kì đỉnh này tới bất kì đỉnh nào khác. <strong>Một thành phần liên thông mạnh</strong> của một đồ thị có hướng là một đồ thị con tối đại liên thông mạnh. Nếu mỗi <strong>thành phần liên thông mạnh</strong> được <strong>co lại</strong> thành một đỉnh, thì đồ thị sẽ trở thành một <strong>đồ thị có hướng không có chu trình</strong>. Khi dựng đồ thị mới ta sẽ có cung $(u,v)$ nếu tồn tại một đỉnh $x$ bất kì nằm trong thành phần liên thông mạnh mang nhãn $u$ có cung tới một đỉnh $y$ bất kì nằm trong thành phần liên thông mạnh mang nhãn $v$.</li>
<li>
<strong>Mấu chốt của bài toán này là:</strong> Tìm ra được các thành phần liên thông mạnh, co từng thành phần liên thông mạnh thành $1$ đỉnh. Lúc này đồ thị mới sẽ là <strong>đồ thị DAG (Directed Acyclic Graph)</strong>. Đây là đồ thị <strong>"một đi không trở lại"</strong>, vậy nên ta dễ dàng <strong>QHĐ trên đồ thị DAG</strong>.</li>
<li>
<strong>Công thức QHĐ trên đồ thị DAG:</strong> $f[u] = max(f[v]) + C[u]$ với mọi $u$ có cung trực tiếp đi tới $v$; trong đó $C[u]$ là tổng giá trị kinh tế của đỉnh $u$ , $f[u]$ là tổng giá trị kinh tế lớn nhất khi ta xuất phát tại $u$ và kết thúc tại $1$ đỉnh bất kì vì ta có thể đi từ $u$ sang $v$ rồi đi theo đường đi tối ưu xuất phát tại $v$ ($u,v$ ở đây là các đỉnh trên đồ thị $DAG$ được tạo ra).</li>
</ul>
<h3 class="editable"><a class="anchor" id="cài-đặt-4" href="#cài-đặt-4"></a><strong>Cài đặt</strong></h3>
<p><strong>Cấu trúc dữ liệu:</strong></p>
<ul>
<li>Để có thể dễ dàng cài đặt thì ta sẽ sử dụng kĩ thuật <strong>"Biến mảng 2 chiều thành mảng 1 chiều"</strong> nhằm mục đích lưu giá trị ô $(i, j)$ vào ô $(i - 1) \cdot N + j$.</li>
<li>Hằng số <code>maxN = 100010</code>
</li>
<li>Hằng số <code>INF = 1000000007</code>
</li>
<li>Biến <code>timeDfs</code> - Thứ tự $DFS$</li>
<li>Biến <code>scc</code> - Số lượng thành phần liên thông mạnh</li>
<li>Mảng <code>a[]</code> - Lưu các dữ liệu vào.</li>
<li>Mảng <code>val[]</code> - Lưu giá trị kinh tế của loại cây.</li>
<li>Mảng <code>totalScc[]</code> - Lưu tổng giá trị kinh tế của từng thành phần liên thông mạnh.</li>
<li>Mảng <code>root[]</code> - Lưu ô $(i, j)$ thuộc thành phần liên thông nào? Ta sẽ lấy thứ tự của thành phần liên thông làm đỉnh ảo trong đồ thị $DAG$.</li>
<li>Mảng <code>low[], num[]</code>
</li>
<li>Mảng <code>deleted[]</code> - Đánh dấu các đỉnh đã bị xóa</li>
<li>Mảng <code>f[]</code> - Mảng quy hoạch động</li>
<li>Vector <code>g[]</code> - Lưu đồ thị ban đầu.</li>
<li>Vector <code>h[]</code> - Lưu đồ thị mới (<strong>đồ thị <em>DAG</em></strong>).</li>
</ul>
<pre class="highlight"><code><span class="cp">#include &lt;bits/stdc++.h&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
 
<span class="k">const</span> <span class="kt">int</span> <span class="n">maxN</span> <span class="o">=</span> <span class="mi">100010</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">INF</span>  <span class="o">=</span> <span class="mf">1e9</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;</span>
 
<span class="kt">int</span> <span class="n">dx</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">dy</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">};</span>

<span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">a</span><span class="p">[</span><span class="n">maxN</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">val</span><span class="p">[</span><span class="n">maxN</span><span class="p">],</span> <span class="n">totalScc</span><span class="p">[</span><span class="n">maxN</span><span class="p">];</span>

<span class="cm">/* Lưu đồ thị ban đầu*/</span>
<span class="n">vector</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">[</span><span class="n">maxN</span><span class="p">];</span>

<span class="cm">/* Lưu đồ thị mới*/</span>
<span class="n">vector</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">[</span><span class="n">maxN</span><span class="p">];</span>

<span class="cm">/* Kỹ thuật "Biến mảng 2 chiều thành mảng 1 chiều" */</span>
<span class="kt">int</span> <span class="nf">getId</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">){</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Kiểm tra ô (i, j) có được đi vào không? */</span>
<span class="kt">bool</span> <span class="nf">check</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">getId</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span> <span class="o">==</span> <span class="sc">'#'</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Tìm thành phần liên thông mạnh*/</span>
<span class="kt">int</span> <span class="n">root</span><span class="p">[</span><span class="n">maxN</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">low</span><span class="p">[</span><span class="n">maxN</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">maxN</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">deleted</span><span class="p">[</span><span class="n">maxN</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">timeDfs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">scc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">stack</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">st</span><span class="p">;</span>
 
<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">timeDfs</span><span class="p">;</span>
    <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">deleted</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
            <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
    <span class="p">}</span>
 
    <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">scc</span><span class="o">++</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">v</span><span class="p">;</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
            <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">deleted</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

            <span class="cm">/* Tính tổng giá trị kinh tế của thành phần liên thông */</span>
            <span class="n">totalScc</span><span class="p">[</span><span class="n">scc</span><span class="p">]</span> <span class="o">+=</span> <span class="n">val</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>

            <span class="cm">/*Đỉnh scc sẽ là đỉnh ảo đại diện cho v trong đồ thị DAG*/</span>
            <span class="n">root</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">scc</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">u</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
 

<span class="cm">/* Quy hoạch động trên đồ thị DAG */</span>
<span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="n">maxN</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">solve</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="n">totalScc</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="o">-</span><span class="n">INF</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">solve</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">totalScc</span><span class="p">[</span><span class="n">u</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* Xử lý dữ liệu đầu vào */</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">m</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">getId</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
            <span class="n">val</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="sc">'0'</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">'9'</span><span class="p">)</span> <span class="o">?</span> <span class="n">a</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'0'</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="cm">/* Xây dựng đồ thị ban đầu */</span> 
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">getId</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'#'</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">check</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">getId</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">check</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">getId</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">));</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'W'</span> <span class="o">&amp;&amp;</span> <span class="n">check</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> 
                <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">getId</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'N'</span> <span class="o">&amp;&amp;</span> <span class="n">check</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span> 
                <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">getId</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Tìm thành phần liên thông mạnh*/</span> 
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">getId</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">check</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span> <span class="n">dfs</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
        <span class="p">}</span>

    <span class="cm">/* Xây dựng đồ thị mới */</span> 
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">u</span>  <span class="o">=</span> <span class="n">getId</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
            <span class="kt">int</span> <span class="n">ru</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ru</span> <span class="o">!=</span> <span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* Có cung đi từ ru đến rv trên đồ thị mới do đỉnh 
                u trong TPLTM ru đi được tới đỉnh v trong TPLTM rv*/</span>
                    <span class="n">h</span><span class="p">[</span><span class="n">ru</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">rv</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">fill</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span> <span class="o">+</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">solve</span><span class="p">(</span><span class="n">root</span><span class="p">[</span><span class="n">getId</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]);</span>
<span class="p">}</span></code></pre>
<h3 class="editable"><a class="anchor" id="đánh-giá-4" href="#đánh-giá-4"></a><strong>Đánh giá</strong></h3>
<ul>
<li>Độ phức tạp của bài toán là $O(N \cdot M)$</li>
</ul>
<h1 class="editable"><a class="anchor" id="bài-tập-vận-dụng" href="#bài-tập-vận-dụng"></a>Bài tập vận dụng</h1>
<h3 class="editable"><a class="anchor" id="khớp-cầu" href="#khớp-cầu"></a>Khớp cầu</h3>
<p><a href="https://oj.vnoi.info/problem/weather">WEATHER - Điều kiện thời tiết</a></p>
<p><a href="https://oj.vnoi.info/problem/critical/">CRITICAL - Thành phố trọng yếu</a></p>
<p><a href="https://www.spoj.com/PTIT/problems/BCACM11E/">BCACM11E - Phương án bắn pháo</a></p>
<p><a href="https://oj.vnoi.info/problem/safenet2">SAFENET2 - Mạng máy tính an toàn </a></p>
<p><a href="https://oj.vnoi.info/problem/reform">REFORM - VOI 2015 Day 1 - Kế hoạch cải tổ</a></p>
<h3 class="editable"><a class="anchor" id="thành-phần-liên-thông-mạnh" href="#thành-phần-liên-thông-mạnh"></a>Thành phần liên thông mạnh</h3>
<p><a href="https://codeforces.com/contest/894/problem/E">Ralph and Mushrooms</a></p>
<p><a href="https://codeforces.com/contest/427/problem/C">Checkposts</a></p>
<p><a href="https://oj.vnoi.info/problem/message">MESSAGE - Truyền tin</a></p>
<p><a href="https://oj.vnoi.info/problem/treat">TREAT - Cho kẹo hay bị phá nào</a></p>
</div>
</div>
</div>
</div>
