<div id="wiki-content">
<h1 class="pt-4">Lowest Common Ancestor (LCA) - Binary Lifting</h1>
<div class="breadcrumb"><nav aria-label="Breadcrumb"><ol>
<li class="breadcrumb-item"><a href="https://vnoi.info/wiki/gollum/overview/algo/">algo</a></li>
<li class="breadcrumb-item"><a href="https://vnoi.info/wiki/gollum/overview/algo/data-structures/">data-structures</a></li>
</ol></nav></div>
<div class>
<div id="wiki-body" class="gollum-markdown-content overflow-hidden ">
<div class="markdown-body ">
<p><strong>Tác giả:</strong></p>
<ul>
<li>Lê Minh Hoàng - Phổ thông Năng khiếu, ĐHQG-HCM</li>
</ul>
<p><strong>Reviewer:</strong></p>
<ul>
<li>Trần Quang Lộc - ITMO University</li>
<li>Hồ Ngọc Vĩnh Phát - Đại học Khoa học Tự nhiên, ĐHQG-HCM</li>
<li>Nguyễn Phú Bình - THPT Chuyên Hùng Vương, Bình Dương</li>
<li>Trần Xuân Bách - THPT Chuyên Khoa học Tự nhiên, ĐHQGHN</li>
</ul>
<hr/>
<p></p><div class="toc"><div class="toc-title">Table of Contents</div><ul><li><a href="#giới-thiệu">Giới thiệu</a></li><li><a href="#bài-toán">Bài toán</a><ul><li><a href="#ngây-thơ">Ngây thơ</a><ul><li><a href="#phân-tích">Phân tích:</a></li></ul></li></ul></li><li><a href="#binary-lifting-nâng-nhị-phân">Binary Lifting (nâng nhị phân)</a><ul><li><a href="#bài-toán-1">Bài toán 1</a><ul><li><a href="#thuật-toán-ngây-thơ">Thuật toán ngây thơ</a><ul><li><a href="#phân-tích-1">Phân tích:</a></li></ul></li><li><a href="#thuật-toán-tối-ưu-1-1">Thuật toán tối ưu 1.1</a><ul><li><a href="#phân-tích-2">Phân tích:</a></li></ul></li><li><a href="#thuật-toán-tối-ưu-1-2">Thuật toán tối ưu 1.2</a><ul><li><a href="#phân-tích-3">Phân tích:</a></li></ul></li><li><a href="#thuật-toán-tối-ưu-1-3">Thuật toán tối ưu 1.3</a><ul><li><a href="#phân-tích-4">Phân tích:</a></li></ul></li><li><a href="#thuật-toán-tối-ưu-2">Thuật toán tối ưu 2</a></li><li><a href="#thuật-toán-tối-ưu-3">Thuật toán tối ưu 3</a></li></ul></li><li><a href="#bài-toán-2">Bài toán 2</a><ul><li><a href="#thuật-toán-1">Thuật toán 1</a><ul><li><a href="#phân-tích-5">Phân tích</a></li></ul></li><li><a href="#thuật-toán-2">Thuật toán 2</a><ul><li><a href="#phân-tích-6">Phân tích</a></li></ul></li></ul></li><li><a href="#ứng-dụng-binary-lifting-vào-bài-toán-lca">Ứng dụng Binary Lifting vào bài toán LCA</a></li><li><a href="#phân-tích-7">Phân tích:</a></li></ul></li><li><a href="#bài-toán-1-1">Bài toán 1</a><ul><li><a href="#tóm-tắt">Tóm tắt</a></li><li><a href="#ý-tưởng">Ý tưởng</a></li><li><a href="#cài-đặt">Cài đặt</a></li></ul></li><li><a href="#bài-toán-2-1">Bài toán 2</a><ul><li><a href="#tóm-tắt-1">Tóm tắt</a></li><li><a href="#ý-tưởng-1">Ý tưởng</a></li><li><a href="#thuật-toán">Thuật toán</a></li><li><a href="#cài-đặt-1">Cài đặt</a></li></ul></li><li><a href="#bài-toán-3">Bài toán 3</a><ul><li><a href="#tóm-tắt-2">Tóm tắt</a></li><li><a href="#thuật-toán-1">Thuật toán</a></li><li><a href="#cài-đặt-2">Cài đặt</a></li></ul></li><li><a href="#bài-tập-áp-dụng">Bài tập áp dụng</a></li></ul></div>
<h1 class="editable"><a class="anchor" id="giới-thiệu" href="#giới-thiệu"></a>Giới thiệu</h1>
<p>Bài toán tìm tổ tiên chung gần nhất (Lowest Common Ancestor - LCA) là một dạng bài quen thuộc thường gặp trong các cuộc thi lập trình thi đấu.</p>
<p>Bài toán tìm LCA có nhiều cách giải:</p>
<ul>
<li>
<strong>Binary Lifting (Sparse Table)</strong>: $\mathcal{O}(N\log{N})$ tiền xử lý, $\mathcal{O}(\log{N})$ mỗi truy vấn.</li>
<li>
<strong>Euler Tour + RMQ (Segment tree)</strong>: $\mathcal{O}(N)$ tiền xử lý, $\mathcal{O}(\log{N})$ mỗi truy vấn.</li>
<li>
<strong>Euler Tour + RMQ (Sparse Table)</strong>: $\mathcal{O}(N\log{N})$ tiền xử lý, $\mathcal{O}(1)$ mỗi truy vấn.</li>
<li>$\dots$</li>
</ul>
<p>Trong bài viết này, ta tập trung vào cách đầu tiên là sử dụng kỹ thuật Binary Lifting để tìm LCA.</p>
<p><strong>Lưu ý:</strong> Trong suốt bài viết mình dùng <code>__lg(x)</code> để tính $\log_2$ của 1 số vì ta cần giá trị nguyên, còn <code>log2(x)</code> thì trả về số thực. Nếu không muốn dùng hàm thì có thể tính trước như sau:
</p><pre class="highlight"><code><span class="kt">int</span> <span class="n">lg2</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">preprocess</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lg2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">lg2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lg2</span><span class="p">[</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<h1 class="editable"><a class="anchor" id="bài-toán" href="#bài-toán"></a>Bài toán</h1>
<p>Cho một cây gồm $N$ đỉnh có gốc tại đỉnh $1$. Có $Q$ truy vấn, mỗi truy vấn gồm $1$ cặp số $(u, v)$ và ta cần tìm LCA của $u$ và $v$, tức là tìm một đỉnh $w$ xa gốc nhất nằm trên đường đi từ $u$ và $v$ đến gốc. Đặc biệt, nếu $u$ là tổ tiên của $v$, thì $u$ là LCA của $u$ và $v$.</p>
<p>Giới hạn: $N, Q \leq 2 \cdot 10^5$</p>
<p><img src="https://i.imgur.com/f5rB83v.png%20=215x339" /></p>
<h2 class="editable"><a class="anchor" id="ngây-thơ" href="#ngây-thơ"></a>Ngây thơ</h2>
<ul>
<li>Đặt $h(u)$ là độ cao của đỉnh $u$ (độ cao của $1$ đỉnh được định nghĩa bằng khoảng cách từ đỉnh đó đến gốc của cây). Ví dụ: $h(1) = 0, h(3) = 1, h(9) = 3,\ldots$</li>
<li>Để trả lời truy vấn $(u, v)$, không mất tính tổng quát, giả sử $h(u) &gt; h(v)$:
<ul>
<li>
<strong>Bước 1:</strong> lặp lại thao tác cho $u$ nhảy lên cha của $u$ đến khi $h(u) = h(v)$.</li>
<li>
<strong>Bước 2:</strong> lặp lại thao tác cho $u$ và $v$ nhảy lên cha của chúng đến khi $u$ và $v$ trùng nhau (đỉnh đó là LCA của $u$ và $v$ ban đầu).</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/05jxDTf.gif%20=295x335" /></p>
<p>Ví dụ:</p>
<ul>
<li>Ta cần tìm LCA của $u$ và $v$. Ban đầu $h(u) &gt; h(v)$.</li>
<li>Ta lặp lại thao tác cho $u$ nhảy lên cha của $u$ đến khi $h(u) = h(v)$:
<ul>
<li>$u = par[u] = u4$</li>
<li>$u = par[u] = u3$</li>
<li>dừng thao tác vì $h(u) = h(v)$</li>
</ul>
</li>
<li>Sau đó, ta cho $u$ và $v$ nhảy lên cha của chúng và lặp lại thao tác đến khi $2$ đỉnh này trùng nhau:
<ul>
<li>$u = par[u] = u2, v = par[v] = v2$</li>
<li>$u = par[u] = u1, v = par[v] = v1$</li>
<li>$u = par[u] = lca, v = par[v] = lca$</li>
<li>dừng thao tác vì $u$ và $v$ trùng nhau ($u = v = lca$)</li>
</ul>
</li>
</ul>
<pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">[</span><span class="n">N</span><span class="p">];</span> <span class="c1">// g[u]: tập các đỉnh kề với u</span>
<span class="kt">int</span> <span class="n">par</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>     <span class="c1">// par[u] = p nếu cha của u là p</span>
<span class="kt">int</span> <span class="n">h</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">par</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">lca</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Không mất tính tổng quát, xét h[u] &gt;= h[v]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="n">swap</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

    <span class="c1">// cho u nhảy lên cha đến khi h[u] = h[v]</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>

    <span class="c1">// cho u và v nhảy lên cha đến khi u trùng v</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">u</span> <span class="o">!=</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<h3 class="editable"><a class="anchor" id="phân-tích" href="#phân-tích"></a>Phân tích:</h3>
<ul>
<li>Độ phức tạp tiền xử lý: $\mathcal{O}(N)$ (tạo mảng $h$)</li>
<li>Độ phức tạp khi truy vấn: $\mathcal{O}(N)$ (độ cao tối đa của 1 đỉnh là $N-1$ nên số bước nhảy tối đa là $N-1$)</li>
<li>Có $Q$ truy vấn, vì thế tổng độ phức tạp là $\mathcal{O}(N + Q \cdot N) = O(Q \cdot N)$</li>
</ul>
<p>Đối chiếu giới hạn, cách "ngây thơ" trên tỏ ra chậm chạp, không đủ để xử lí yêu cầu bài toán.</p>
<h1 class="editable"><a class="anchor" id="binary-lifting-nâng-nhị-phân" href="#binary-lifting-nâng-nhị-phân"></a>Binary Lifting (nâng nhị phân)</h1>
<p>Đầu tiên, ta sẽ tìm hiểu về ý tưởng của Binary Lifting qua bài toán con của $LCA$.</p>
<h2 class="editable"><a class="anchor" id="bài-toán-1" href="#bài-toán-1"></a>Bài toán 1</h2>
<p>Cho một cây gồm $N$ đỉnh có gốc tại đỉnh $1$. Có $Q$ truy vấn, mỗi truy vấn gồm $1$ cặp số $(u, k)$, ta cần in ra tổ tiên thứ $k$ của $u$ (tổ tiên thứ $k$ của $u$ là $par[par[\ldots[u \underset{\color{blue}{k \text{ lần}}}{\color{blue}{\underbrace{\color{blue}{]\ldots]]}}}}$ ).</p>
<p>Giới hạn: $N, Q \leq 10^5$</p>
<h3 class="editable"><a class="anchor" id="thuật-toán-ngây-thơ" href="#thuật-toán-ngây-thơ"></a>Thuật toán ngây thơ</h3>
<p>Ta lặp lại câu lệnh <code>u = par[u]</code> trong k lần.
</p><pre class="highlight"><code><span class="kt">int</span> <span class="n">par</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">ancestor_k</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
        <span class="o">--</span><span class="n">k</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<h4 class="editable"><a class="anchor" id="phân-tích-1" href="#phân-tích-1"></a>Phân tích:</h4>
<ul>
<li>Độ phức tạp tiền xử lý: $\mathcal{O}(N)$ (tạo mảng $par$)</li>
<li>Độ phức tạp truy vấn: $\mathcal{O}(K) = \mathcal{O}(N)$</li>
<li>Có $Q$ truy vấn, vì thế tổng độ phức tạp là $\mathcal{O}(N + Q \cdot N)$</li>
</ul>
<p>Câu hỏi đặt ra là ta còn có thể tối ưu thời gian truy vấn được hay không?</p>
<ul>
<li>Nhận xét: Thay vì nhảy từng bước nhỏ độ dài $1$, ta có thể nhảy các bước lớn độ dài $2$. Từ đó, ta có thể giảm thời gian truy vấn xuống còn $\mathcal{O}(\frac{K}2)$</li>
</ul>
<h3 class="editable"><a class="anchor" id="thuật-toán-tối-ưu-1-1" href="#thuật-toán-tối-ưu-1-1"></a>Thuật toán tối ưu 1.1</h3>
<ul>
<li>Ta xây dựng mảng $up2[N]$ là tổ tiên thứ $2$ của mỗi đỉnh.</li>
<li>Khi truy vấn, ta nhảy các bước độ dài $2$ trước, sau đó kiểm tra xem $k$ có $\geq 1$ hay không (vì $k$ mod $2$ dư $0$ hoặc $1$).</li>
</ul>
<pre class="highlight"><code><span class="kt">int</span> <span class="n">par</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">up2</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">preprocess</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">u</span><span class="p">)</span>
        <span class="n">up2</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">]];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ancestor_k</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">up2</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
        <span class="n">k</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
        <span class="o">--</span><span class="n">k</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<h4 class="editable"><a class="anchor" id="phân-tích-2" href="#phân-tích-2"></a>Phân tích:</h4>
<ul>
<li>Độ phức tạp tiền xử lý: $\mathcal{O}(2N)$ (tạo mảng $par$ và $up2$)</li>
<li>Độ phức tạp truy vấn: $\mathcal{O}(\frac{K}2 + 1) = \mathcal{O}(\frac{N}2 + 1)$ (1 vòng while và 1 lệnh if)</li>
<li>Có $Q$ truy vấn, vì thế tổng độ phức tạp thời gian là $\mathcal{O}(2N + Q \cdot (\frac{N}2 + 1))$</li>
<li>Độ phức tạp bộ nhớ: $\mathcal{O}(2N)$ (2 mảng $par$ và $up2$)</li>
</ul>
<h3 class="editable"><a class="anchor" id="thuật-toán-tối-ưu-1-2" href="#thuật-toán-tối-ưu-1-2"></a>Thuật toán tối ưu 1.2</h3>
<p>Ta còn có thể tối ưu thời gian truy vấn được hay không?</p>
<ul>
<li>Nhận xét: Thay vì nhảy từng bước nhỏ độ dài $2$, ta có thể nhảy các bước lớn độ dài $4$. Từ đó, ta có thể giảm thời gian truy vấn xuống còn $\mathcal{O}(\frac{K}4)$.</li>
</ul>
<pre class="highlight"><code><span class="kt">int</span> <span class="n">par</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">up2</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">up4</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">preprocess</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">u</span><span class="p">)</span> <span class="n">up2</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">]];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">u</span><span class="p">)</span> <span class="n">up4</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">up2</span><span class="p">[</span><span class="n">up2</span><span class="p">[</span><span class="n">u</span><span class="p">]];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ancestor_k</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="n">u</span> <span class="o">=</span> <span class="n">up4</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">k</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">u</span> <span class="o">=</span> <span class="n">up2</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">k</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">u</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="o">--</span><span class="n">k</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<h4 class="editable"><a class="anchor" id="phân-tích-3" href="#phân-tích-3"></a>Phân tích:</h4>
<ul>
<li>Độ phức tạp tiền xử lý: $\mathcal{O}(3N)$ (tạo mảng $par$, $up2$ và $up4$)</li>
<li>Độ phức tạp truy vấn: $\mathcal{O}(\frac{K}4 + 2) = \mathcal{O}(\frac{N}4 + 2)$ (1 vòng while và 2 lệnh if)</li>
<li>Có $Q$ truy vấn, vì thế tổng độ phức tạp thời gian là $\mathcal{O}(3N + Q \cdot (\frac{N}4 + 2))$</li>
<li>Độ phức tạp bộ nhớ: $\mathcal{O}(3N)$ (3 mảng $par$, $up2$ và $up4$)</li>
</ul>
<h3 class="editable"><a class="anchor" id="thuật-toán-tối-ưu-1-3" href="#thuật-toán-tối-ưu-1-3"></a>Thuật toán tối ưu 1.3</h3>
<p>Ta vẫn có thể tối ưu thời gian truy vấn bằng cách nhảy các bước lớn hơn (độ dài $8$).</p>
<pre class="highlight"><code><span class="kt">int</span> <span class="n">par</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">up2</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">up4</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">up8</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">preprocess</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">u</span><span class="p">)</span> <span class="n">up2</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">]];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">u</span><span class="p">)</span> <span class="n">up4</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">up2</span><span class="p">[</span><span class="n">up2</span><span class="p">[</span><span class="n">u</span><span class="p">]];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">u</span><span class="p">)</span> <span class="n">up8</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">up4</span><span class="p">[</span><span class="n">up4</span><span class="p">[</span><span class="n">u</span><span class="p">]];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ancestor_k</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">)</span> <span class="n">u</span> <span class="o">=</span> <span class="n">up8</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">k</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="n">u</span> <span class="o">=</span> <span class="n">up4</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">k</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">u</span> <span class="o">=</span> <span class="n">up2</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">k</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">u</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="o">--</span><span class="n">k</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<h4 class="editable"><a class="anchor" id="phân-tích-4" href="#phân-tích-4"></a>Phân tích:</h4>
<ul>
<li>Độ phức tạp tiền xử lý: $\mathcal{O}(4N)$ (tạo mảng $par$, $up2$, $up4$ và $up8$)</li>
<li>Độ phức tạp truy vấn: $\mathcal{O}(\frac{K}8 + 3) = \mathcal{O}(\frac{N}8 + 3)$ (1 vòng while và 3 lệnh if)</li>
<li>Có $Q$ truy vấn, vì thế tổng độ phức tạp thời gian là $\mathcal{O}(4N + Q \cdot (\frac{N}8 + 3))$</li>
<li>Độ phức tạp tiền xử lý: $\mathcal{O}(4N)$ (4 mảng $par$, $up2$, $up4$ và $up8$)</li>
</ul>
<h3 class="editable"><a class="anchor" id="thuật-toán-tối-ưu-2" href="#thuật-toán-tối-ưu-2"></a>Thuật toán tối ưu 2</h3>
<p>Nếu ta làm tiếp như thuật toán tối ưu $1.3$ (tiếp tục tạo các mảng $up16, up32, \dots, up65536$) ta sẽ có $\log_2(N)$ mảng up, độ phức tạp bài toán lúc này như sau:</p>
<ul>
<li>Độ phức tạp tiền xử lý: $\mathcal{O}(N \cdot (1 + \log_2(N)) = \mathcal{O}(N \cdot \log_2(N))$ (mảng $par$ và $\log_2$ mảng $up$)</li>
<li>Độ phức tạp truy vấn: $\mathcal{O}(\frac{K}{2^{\log_2(N)}} + \log_2(N)) = \mathcal{O}(\log_2(N))$ (1 vòng while và $log_2$ lệnh if)</li>
<li>Có $Q$ truy vấn, vì thế tổng độ phức tạp thời gian là $\mathcal{O}(N \cdot \log_2(N) + Q \cdot \log_2(N))$</li>
<li>Độ phức tạp bộ nhớ: $\mathcal{O}(N \cdot \log_2(N))$ (mảng $par$ và $\log_2$ mảng $up$)</li>
</ul>
<p>Nhưng nếu dùng $\log_2$ mảng $up$ sẽ mang đến cho ta nhiều bất tiện (code dài, dễ sai,…). Do đó, ta có thể đặt:</p>
<ul>
<li>$up[u][j]$ là tổ tiên thứ $2^j$ của $u$ (tương ứng $up2^j[u]$).
<ul>
<li>Cha của $u$ là tổ tiên thứ $1$ (đầu tiên) của $u$.
<ul>
<li>$up[u][0] = par[u]$</li>
</ul>
</li>
<li>Đặt $x$ là tổ tiên thứ $2^{j-1}$ của $u$, ta có, tổ tiên thứ $2^{j-1}$ của $x$ là tổ tiên thứ $2^j$ của $u$ (vì $2^{j-1} + 2^{j-1} = 2^j$)</li>
</ul>
</li>
</ul>
<div class="kdmath">$$
\begin{cases}
x &amp;= up[u][j - 1] \\
up[u][j] &amp;= up[x][j - 1]
\end{cases}
$$</div>
<ul>
<li>Ta có công thức truy hồi sau:</li>
</ul>
<div class="kdmath">$$
\begin{cases}
up[u][j] = par[u] &amp; \text{ với } j = 0 \\
up[u][j] = up[up[u][j-1]][j-1] &amp; \text{ với } j &gt; 0 \text{ và } 2^j \leq h[u] \\
up[u][j] = 0 \text{ (NULL)} &amp; \text{ với } j &gt; 0 \text{ và } 2^j &gt; h[u]
\end{cases}
$$</div>
<pre class="highlight"><code><span class="kt">int</span> <span class="n">par</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">up</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="mi">17</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">preprocess</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">u</span><span class="p">)</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">17</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">u</span><span class="p">)</span>
            <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ancestor_k</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">))</span> <span class="n">u</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<h3 class="editable"><a class="anchor" id="thuật-toán-tối-ưu-3" href="#thuật-toán-tối-ưu-3"></a>Thuật toán tối ưu 3</h3>
<p>Nhận xét: Ta luôn có thể tách một số nguyên dương thành tổng các lũy thừa phân biệt của 2 (hệ nhị phân). Ví dụ: $25 = 2^4 + 2^3 + 2^0 = 11001_2$.</p>
<p>Từ nhận xét trên, ta có một cách khác để nhảy lên tổ tiên thứ $k$ của $u$ là duyệt $j$ từ $0$ đến $\log_2(k)$, nếu bit thứ $j$ của $k$ là $1$ thì ta cho $u$ nhảy lên tổ tiên thứ $2^j$ của nó.</p>
<pre class="highlight"><code><span class="kt">int</span> <span class="n">par</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">up</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="mi">17</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">preprocess</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">u</span><span class="p">)</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">17</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">u</span><span class="p">)</span>
            <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ancestor_k</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;&gt;</span> <span class="n">j</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="n">u</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<p>Qua đó, ta có thể thấy rằng Binary Lifting chỉ đơn giản là một cách tiền xử lý dữ liệu nhằm giúp cho thời gian truy vấn tối ưu hơn. Về tính chất, Binary Lifting khá giống với chặt nhị phân, khác ở chỗ mỗi lần, Binary Lifting thì ta thử nhảy $2^k$ đơn vị, còn chặt nhị phân thì ta thử nhảy $\frac{hi - lo + 1}{2}$ đơn vị.</p>
<h2 class="editable"><a class="anchor" id="bài-toán-2" href="#bài-toán-2"></a>Bài toán 2</h2>
<p>Cho một cây có trọng số gồm $N$ đỉnh có gốc tại đỉnh $1$. Có $Q$ truy vấn, mỗi truy vấn gồm $1$ cặp số $(u, x)$, ta cần in ra $v$ là tổ tiên xa nhất của $u$ thỏa tổng trọng số trên đường đi từ $u$ đến $v$ $\leq x$. Giới hạn: $N, Q \leq 10^5$</p>
<h3 class="editable"><a class="anchor" id="thuật-toán-1" href="#thuật-toán-1"></a>Thuật toán 1</h3>
<p>Ta xây dựng mảng $dist[u][j]$ là khoảng cách từ $u$ đến tổ tiên thứ $2^j$ của $u$.</p>
<p>Cách làm dễ nhận ra là chặt nhị phân giá trị của $k$, sau đó so sánh $x$ với khoảng cách từ $u$ đến tổ tiên thứ $k$ của $u$.</p>
<pre class="highlight"><code><span class="kt">int</span> <span class="n">dist</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="mi">17</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">calc_dist</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;&gt;</span> <span class="n">j</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">solve</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">mid</span><span class="p">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">lo</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">calc_dist</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>    
            <span class="n">lo</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ancestor_k</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
<span class="p">}</span></code></pre>
<h4 class="editable"><a class="anchor" id="phân-tích-5" href="#phân-tích-5"></a>Phân tích</h4>
<ul>
<li>Độ phức tạp tiền xử lý: $\mathcal{O}(N\log N)$ (tạo mảng $up$ và $dist$)</li>
<li>Độ phức tạp truy vấn: $\mathcal{O}(\log N)$ (chặt nhị phân) $\times$ $\mathcal{O}(\log N)$ (tính khoảng cách) = $\mathcal{O}(\log^2N)$</li>
<li>Có $Q$ truy vấn, vì thế tổng độ phức tạp là $\mathcal{O}(N\log N + Q\log^2N)$</li>
</ul>
<h3 class="editable"><a class="anchor" id="thuật-toán-2" href="#thuật-toán-2"></a>Thuật toán 2</h3>
<p>Ta có nhận xét:</p>
<ul>
<li>Ta đã tính trước các khoảng cách có độ lớn $2^j$ (mảng $dist$)</li>
<li>Từ đó, ta có thể nhảy theo từng bước $2^j$ để tính khoảng cách trong $\mathcal{O}(1)$</li>
</ul>
<p><img src="https://i.imgur.com/DQaPNFx.gif%20=610x380" /></p>
<pre class="highlight"><code><span class="kt">int</span> <span class="n">dist</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="mi">17</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">solve</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">now_dist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">__lg</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]);</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// nếu khoảng cách từ u ban đầu đến tổ tiên thứ (k + 2^j) &lt;= x</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">now_dist</span> <span class="o">+</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">now_dist</span> <span class="o">+=</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="n">k</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">;</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<h4 class="editable"><a class="anchor" id="phân-tích-6" href="#phân-tích-6"></a>Phân tích</h4>
<ul>
<li>Độ phức tạp tiền xử lý: $\mathcal{O}(N\log N)$ (tạo mảng $up$ và $dist$)</li>
<li>Độ phức tạp truy vấn: $\mathcal{O}(\log N)$ (chặt nhị phân) $\times$ $\mathcal{O}(1)$ (tính khoảng cách) = $\mathcal{O}(\log N)$</li>
<li>Có $Q$ truy vấn, vì thế tổng độ phức tạp là $\mathcal{O}(N\log N + Q\log N)$</li>
</ul>
<h2 class="editable"><a class="anchor" id="ứng-dụng-binary-lifting-vào-bài-toán-lca" href="#ứng-dụng-binary-lifting-vào-bài-toán-lca"></a>Ứng dụng Binary Lifting vào bài toán LCA</h2>
<p>Dễ thấy: nếu $x$ là tổ tiên chung của $u$ và $v$ ($x \neq$ gốc) thì $par[x]$ cũng là tổ tiên chung của $u$ và $v$. Do đó, ta có thể tìm tổ tiên chung gần nhất của $u$ và $v$ bằng Binary Lifting.</p>
<p>Bằng cách sử dụng mảng $up$, ta có thể nhảy từ $u$ đến bất kì tổ tiên nào chỉ trong $\mathcal{O}(\log N)$ (bài toán tìm tổ tiên thứ $k$). Ta có thể tính mảng này bằng hàm $DFS$ như sau:</p>
<pre class="highlight"><code><span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        
        <span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

        <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
<p>Bước khởi tạo này chi phí $\mathcal{O}(N\log N)$ bộ nhớ lẫn thời gian.</p>
<p>Cách tìm LCA giống hệt thuật toán ngây thơ 1, nhưng để tăng tốc, thay vì nhảy lên cha ở mỗi bước, ta dùng mảng $up$ để nhảy, từ đó thu được độ phức tạp $\mathcal{O}(\log N)$ cho mỗi truy vấn. Cụ thể:</p>
<ul>
<li>Gọi $h(u)$ là độ cao của đỉnh $u$. Để tính $LCA(u, v)$, giả sử $h(u) &gt; h(v)$, đầu tiên ta tìm $u'$ là tổ tiên của $u$ và có $h(u') = h(v)$:
<ul>
<li>Rõ ràng, ta cần nhảy từ $u$ lên cha thứ $k = h(u) - h(v)$.</li>
</ul>
</li>
<li>Sau khi $u$ và $v$ đã ở cùng độ cao, ta sẽ tính $LCA(u, v)$:
<ul>
<li>Nếu $u = v$ thì $LCA(u, v)$ chính là $u$ và $v$.</li>
<li>Nếu $u \neq v$ thì ta dùng Binary Lifting để tìm $k$ lớn nhất sao cho tổ tiên thứ $k$ của $u$ và $v$ khác nhau (không phải tổ tiên chung). Lúc này, tổ tiên thứ $k+1$ chính là tổ tiên chung của $u$ và $v$.
<ul>
<li>Ta duyệt $j$ từ $\log_2(h(u))$ về $0$</li>
<li>Nếu tổ tiên thứ $2^j$ của $u$ và $v$ khác nhau thì ta cho cả $u$ và $v$ nhảy lên tổ tiên thứ $2^j$ của chúng. Cuối cùng thì $u$ và $v$ sẽ có cùng cha (tổ tiên thứ $k+1$ là cha của tổ tiên thứ $k$), vậy nên khi đó $LCA(u, v) = par[u] = par[v] = up[u][0] = up[v][0]$.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/iC7FKlw.gif%20=432x333" /></p>
<pre class="highlight"><code><span class="kt">int</span> <span class="n">h</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">up</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="mi">20</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">lca</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">!=</span> <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="n">swap</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    
        <span class="c1">// Tìm tổ tiên u' của u sao cho h(u') = h(v)</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">-</span> <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;&gt;</span> <span class="n">j</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// Nếu bit thứ j của k là 1</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
    
    <span class="c1">// Tìm lca(u, v)</span>
    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">__lg</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="c1">// Nếu tổ tiên thứ 2^j của u và v khác nhau</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">v</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span></code></pre>
<h2 class="editable"><a class="anchor" id="phân-tích-7" href="#phân-tích-7"></a>Phân tích:</h2>
<ul>
<li>Độ phức tạp tiền xử lý: $\mathcal{O}(N\log N)$</li>
<li>Độ phức tạp khi truy vấn: $\mathcal{O}(\log N)$</li>
<li>Có $Q$ truy vấn, vì thế tổng độ phức tạp là $\mathcal{O}(N\log N + Q\log N)$</li>
</ul>
<h1 class="editable"><a class="anchor" id="bài-toán-1-1" href="#bài-toán-1-1"></a>Bài toán 1</h1>
<p><a href="https://oj.vnoi.info/problem/pwalk"><strong>VNOJ - PWALK</strong></a></p>
<h2 class="editable"><a class="anchor" id="tóm-tắt" href="#tóm-tắt"></a>Tóm tắt</h2>
<p>Cho $1$ cây $N$ đỉnh có trọng số $(N \le 1000)$. Cần trả lời $Q$ truy vấn, mỗi truy vấn yêu cầu tìm khoảng cách giữa 2 đỉnh $u$ và $v$ trong cây.</p>
<h2 class="editable"><a class="anchor" id="ý-tưởng" href="#ý-tưởng"></a>Ý tưởng</h2>
<p>Chọn đỉnh $1$ làm gốc của cây.
Với mỗi đỉnh của cây, ta tính $f(u)$ là khoảng cách của mỗi đỉnh đến đỉnh $1$ bằng cách duyệt qua tất cả các đỉnh trong cây.</p>
<p><img src="https://i.imgur.com/71qRbBP.png%20=203x311" /></p>
<p>Với hai đỉnh $u$ và $v$ bất kì, xét đường đi từ gốc của cây đến hai đỉnh này. Ta nhận thấy:</p>
<ul>
<li>Phần giao của hai đường đi chính là đường đi từ gốc của cây đến tổ tiên chung gần nhất của $u$ và $v$ - gọi đỉnh này là $p$.</li>
<li>Hiệu giữa phần giao và mỗi đường đi ban đầu là đường đi từ $u$ đến $p$ và đường đi từ $p$ đến $v$.</li>
</ul>
<p>Từ hai quan sát trên, thấy được chỉ cần ba giá trị $f(u)$, $f(v)$ và $f(p)$ để tính $dist(u, v)$. Khi cộng $f(u)$ và $f(v)$, các đỉnh thuộc phần giao bị tính đến 2 lần, vì vậy ta tính $dist(u, v) = f(u) + f(v) - 2 * f(p)$.</p>
<h2 class="editable"><a class="anchor" id="cài-đặt" href="#cài-đặt"></a>Cài đặt</h2>
<pre class="highlight"><code><span class="cp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">q</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">Edge</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">;</span>
    <span class="n">Edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">v</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">w</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="kt">int</span> <span class="n">h</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">up</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="mi">10</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Edge</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>

        <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">f</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span><span class="p">;</span>

        <span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

        <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">lca</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">!=</span> <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="n">swap</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">-</span> <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;&gt;</span> <span class="n">j</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
    
    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">__lg</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">v</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dist</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">lca</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">f</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">c</span><span class="p">;</span>
        <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
        <span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">dfs</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span> <span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dist</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
<h1 class="editable"><a class="anchor" id="bài-toán-2-1" href="#bài-toán-2-1"></a>Bài toán 2</h1>
<p><a href="https://oj.vnoi.info/problem/fselect"><strong>VNOJ - FSELECT</strong></a></p>
<h2 class="editable"><a class="anchor" id="tóm-tắt-1" href="#tóm-tắt-1"></a>Tóm tắt</h2>
<p>Cho $1$ cây $N$ đỉnh và một số nguyên dương $K$ là số nhóm $(N \le 2\cdot 10^5, K \le \frac{N}{2})$. Đỉnh thứ $i$ thuộc nhóm $x_i$.</p>
<p>Output gồm $K$ dòng, dòng thứ $i$ chứa $1$ số nguyên dương là khoảng cách xa nhất giữa $2$ đỉnh bất kì thuộc nhóm thứ $i$.</p>
<h2 class="editable"><a class="anchor" id="ý-tưởng-1" href="#ý-tưởng-1"></a>Ý tưởng</h2>
<ul>
<li>Với bài toán tìm khoảng cách xa nhất giữa 2 đỉnh trên cây, ta có thể làm như sau
<ul>
<li>
<strong>Bước 1:</strong> Chọn 1 đỉnh bất kì, đặt là đỉnh $A$.</li>
<li>
<strong>Bước 2:</strong> Tìm $1$ đỉnh bất kì xa đỉnh $A$ nhất, đặt là $B$.</li>
<li>
<strong>Bước 3:</strong> Tìm $1$ đỉnh bất kì xa đỉnh $B$ nhất, đặt là $C$.</li>
</ul>
</li>
<li>Lúc này, khoảng cách giữa $2$ đỉnh $B$ và $C$ chính là khoảng cách xa nhất giữa $2$ đỉnh trên cây và được định nghĩa là đường kính của cây.</li>
<li>Chứng minh thuật toán: <a href="http://courses.csail.mit.edu/6.046/fall01/handouts/ps9sol.pdf">here</a> (Exercise 9-1).</li>
</ul>
<h2 class="editable"><a class="anchor" id="thuật-toán" href="#thuật-toán"></a>Thuật toán</h2>
<p>Từ bài toán trên, ta có thể tìm khoảng cách lớn nhất giữa 2 đỉnh thuộc mỗi nhóm như sau:</p>
<ul>
<li>
<strong>Bước 1:</strong> Chọn 1 đỉnh bất kì thuộc nhóm, đặt là $A$.</li>
<li>
<strong>Bước 2:</strong> Tìm $1$ đỉnh bất kì thuộc nhóm xa đỉnh $A$ nhất, đặt là $B$.</li>
<li>
<strong>Bước 3:</strong> Tìm khoảng cách lớn nhất từ đỉnh $B$ đến các đỉnh thuộc nhóm còn lại.</li>
</ul>
<h2 class="editable"><a class="anchor" id="cài-đặt-1" href="#cài-đặt-1"></a>Cài đặt</h2>
<pre class="highlight"><code><span class="cp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mf">2e5</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">root</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">group</span><span class="p">[</span><span class="n">N</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">];</span>

<span class="kt">int</span> <span class="n">h</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">up</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="mi">18</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">18</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

        <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">lca</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">!=</span> <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="n">swap</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">-</span> <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;&gt;</span> <span class="n">j</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="k">return</span> <span class="n">u</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">__lg</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">v</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dist</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">lca</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">h</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">diameter</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">meeting</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">A</span> <span class="o">=</span> <span class="n">meeting</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">max_dist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">meeting</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">max_dist</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">max_dist</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">max_dist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">meeting</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="n">max_dist</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max_dist</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">max_dist</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">k</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">up</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">group</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">g</span><span class="p">[</span><span class="n">up</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]].</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">up</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">root</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">diameter</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<h1 class="editable"><a class="anchor" id="bài-toán-3" href="#bài-toán-3"></a>Bài toán 3</h1>
<p><a href="https://oj.vnoi.info/problem/hbtlca"><strong>VNOJ - HBTLCA</strong></a></p>
<h2 class="editable"><a class="anchor" id="tóm-tắt-2" href="#tóm-tắt-2"></a>Tóm tắt</h2>
<p>Cho $1$ cây $N$ đỉnh có gốc là đỉnh $1$ và $M$ truy vấn thuộc $1$ trong $2$ loại:</p>
<ul>
<li>$!$ $root$ : Chọn $root$ làm gốc của cây.</li>
<li>$?$ $u$ $v$ : Tìm tổ tiên chung gần nhất của $2$ đỉnh $u$ và $v$.</li>
</ul>
<p>Giới hạn: $N, M \le 10^5$</p>
<h2 class="editable"><a class="anchor" id="thuật-toán-1" href="#thuật-toán-1"></a>Thuật toán</h2>
<ul>
<li>Xét cây có gốc là đỉnh bất kì (giả sử là đỉnh $1$), trong $3$ đỉnh $lca(u, v)$, $lca(u, root)$, $lca(v, root)$ sẽ luôn tồn tại ít nhất $2$ đỉnh trùng nhau, đỉnh còn lại chính là $lca(u, v)$ trong cây có gốc là $root$.</li>
<li>Phần chứng minh khá dễ, xin phép nhường lại cho bạn đọc như một bài tập.</li>
</ul>
<h2 class="editable"><a class="anchor" id="cài-đặt-2" href="#cài-đặt-2"></a>Cài đặt</h2>
<pre class="highlight"><code><span class="cp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mf">1e5</span> <span class="o">+</span> <span class="mi">9</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="kt">int</span> <span class="n">h</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">up</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="mi">17</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">17</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

        <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">lca</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">!=</span> <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="n">swap</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">-</span> <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;&gt;</span> <span class="n">j</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="k">return</span> <span class="n">u</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">__lg</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">v</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">;</span>
            <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
            <span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">dfs</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

        <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">root</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span> <span class="k">while</span> <span class="p">(</span><span class="n">m</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">c</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'!'</span><span class="p">)</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">root</span><span class="p">;</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">;</span>
                <span class="kt">int</span> <span class="n">uv</span> <span class="o">=</span> <span class="n">lca</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
                <span class="kt">int</span> <span class="n">ur</span> <span class="o">=</span> <span class="n">lca</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
                <span class="kt">int</span> <span class="n">vr</span> <span class="o">=</span> <span class="n">lca</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">uv</span> <span class="o">^</span> <span class="n">ur</span> <span class="o">^</span> <span class="n">vr</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
<h1 class="editable"><a class="anchor" id="bài-tập-áp-dụng" href="#bài-tập-áp-dụng"></a>Bài tập áp dụng</h1>
<ul>
<li><a href="https://www.spoj.com/problems/LCA/"><strong>SPOJ - LCA</strong></a></li>
<li><a href="https://www.spoj.com/problems/QTREE2/"><strong>SPOJ - QTREE2</strong></a></li>
<li><a href="https://oj.vnoi.info/problem/pwalk"><strong>VNOJ - PWALK</strong></a></li>
<li><a href="https://oj.vnoi.info/problem/lubenica"><strong>VNOJ - LUBENICA</strong></a></li>
<li><a href="https://oj.vnoi.info/problem/fselect"><strong>VNOJ - FSELECT</strong></a></li>
<li><a href="https://oj.vnoi.info/problem/hbtlca"><strong>VNOJ - HBTLCA</strong></a></li>
<li><a href="https://oj.vnoi.info/problem/votree"><strong>VNOJ - VOTREE</strong></a></li>
<li><a href="https://oj.vnoi.info/problem/upgranet"><strong>VNOJ - UPGRANET (VOI11)</strong></a></li>
<li><a href="https://oj.vnoi.info/problem/voi17bgame"><strong>VNOJ - BGAME (VOI17)</strong></a></li>
<li><a href="https://codeforces.com/contest/519/problem/E"><strong>Codeforces - 519E</strong></a></li>
<li><a href="https://codeforces.com/contest/916/problem/E"><strong>Codeforces - 916E</strong></a></li>
</ul>
</div>
</div>
</div>
</div>
