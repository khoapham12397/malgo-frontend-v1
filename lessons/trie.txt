<div id="wiki-content">
<h1 class="pt-4">Trie</h1>
<div class="breadcrumb"><nav aria-label="Breadcrumb"><ol>
<li class="breadcrumb-item"><a href="https://vnoi.info/wiki/gollum/overview/algo/">algo</a></li>
<li class="breadcrumb-item"><a href="https://vnoi.info/wiki/gollum/overview/algo/data-structures/">data-structures</a></li>
</ol></nav></div>
<div class>
<div id="wiki-body" class="gollum-markdown-content overflow-hidden ">
<div class="markdown-body ">
<p><strong>Nguời viết:</strong></p>
<ul>
<li>Ngô Nhật Quang - HUS High School for Gifted Students</li>
</ul>
<p><strong>Reviewer:</strong></p>
<ul>
<li>Hồ Ngọc Vĩnh Phát - VNUHCM-University of Science</li>
<li>Lê Minh Hoàng - VNUHCM-University of Science</li>
<li>Cao Thanh Hậu - VNUHCM-University of Science</li>
</ul>
<p></p><div class="toc"><div class="toc-title">Table of Contents</div><ul><li><a href="#giới-thiệu">Giới thiệu</a></li><li><a href="#cấu-trúc">Cấu trúc</a></li><li><a href="#cài-đặt">Cài đặt</a><ul><li><a href="#cài-đặt-bằng-mảng">Cài đặt bằng mảng</a></li><li><a href="#cài-đặt-bằng-con-trỏ">Cài đặt bằng con trỏ</a></li><li><a href="#ưu-và-nhược-điểm-của-cài-đặt-bằng-con-trỏ">Ưu và nhược điểm của cài đặt bằng con trỏ</a></li></ul></li><li><a href="#trie-nhị-phân">Trie nhị phân</a></li><li><a href="#ứng-dụng">Ứng dụng</a><ul><li><a href="#sắp-xếp-một-danh-sách-các-xâu">Sắp xếp một danh sách các xâu</a><ul><li><a href="#bài-toán">Bài toán</a></li><li><a href="#lời-giải">Lời giải</a></li></ul></li><li><a href="#xử-lí-truy-vấn-tiền-tố-chung-dài-nhất-của-hai-xâu">Xử lí truy vấn tiền tố chung dài nhất của hai xâu</a><ul><li><a href="#bài-toán-1">Bài toán</a></li><li><a href="#lời-giải-1">Lời giải</a></li></ul></li><li><a href="#xử-lí-truy-vấn-tìm-xâu-có-thứ-tự-từ-điển-thứ-k">Xử lí truy vấn tìm xâu có thứ tự từ điển thứ k</a><ul><li><a href="#bài-toán-2">Bài toán</a></li><li><a href="#lời-giải-2">Lời giải</a></li></ul></li><li><a href="#xử-lí-truy-vấn-tìm-xor-lớn-nhất-với-giá-trị-được-cho">Xử lí truy vấn tìm XOR lớn nhất với giá trị được cho</a><ul><li><a href="#bài-toán-3">Bài toán</a></li><li><a href="#lời-giải-3">Lời giải</a></li></ul></li></ul></li><li><a href="#áp-dụng">Áp dụng</a><ul><li><a href="#codeforces-kuro-and-gcd-and-xor-and-sum">Codeforces - Kuro and GCD and XOR and SUM
</a><ul><li><a href="#đề-bài">Đề bài</a></li><li><a href="#lời-giải-4">Lời giải</a></li></ul></li><li><a href="#codeforces-vitya-and-strange-lesson">Codeforces - Vitya and Strange Lesson
</a><ul><li><a href="#đề-bài-1">Đề bài</a></li><li><a href="#lời-giải-5">Lời giải</a></li></ul></li><li><a href="#codechef-english">Codechef - English
</a><ul><li><a href="#đề-bài-2">Đề bài</a></li><li><a href="#lời-giải-6">Lời giải</a></li></ul></li><li><a href="#joi-open-contest-2016-selling-rna-strands">JOI Open Contest 2016 - Selling RNA Strands
</a><ul><li><a href="#đề-bài-3">Đề bài</a></li><li><a href="#lời-giải-7">Lời giải</a></li></ul></li><li><a href="#xx-open-cup-grand-prix-of-kazan-bitwise-xor">XX Open Cup, Grand Prix of Kazan - Bitwise Xor
</a><ul><li><a href="#đề-bài-4">Đề bài</a></li><li><a href="#lời-giải-8">Lời giải</a></li></ul></li></ul></li><li><a href="#bài-tập">Bài tập</a><ul><li><a href="#trie-xâu">Trie xâu</a></li><li><a href="#trie-nhị-phân-1">Trie nhị phân</a></li></ul></li></ul></div>
<h1 class="editable"><a class="anchor" id="giới-thiệu" href="#giới-thiệu"></a>Giới thiệu</h1>
<p><strong>Trie</strong>, hay một số tài liệu còn gọi là <strong>cây tiền tố</strong>, là một cấu trúc dữ liệu dạng <strong>cây</strong> hữu dụng được dùng để quản lí một tập hợp các xâu. Mặc dù dễ hiểu và dễ cài đặt, trie lại có rất nhiều ứng dụng. Do vậy, trie thường xuyên xuất hiện trong các cuộc thi lập trình ở Việt Nam nói riêng và quốc tế nói chung.</p>
<p>Một trie cơ bản có thể thực hiện ba thao tác sau với độ phức tạp thời gian tuyến tính:</p>
<ul>
<li>Thêm một xâu vào tập hợp</li>
<li>Xóa một xâu khỏi tập hợp</li>
<li>Kiểm tra một xâu có nằm trong tập hợp đó hay không</li>
</ul>
<h1 class="editable"><a class="anchor" id="cấu-trúc" href="#cấu-trúc"></a>Cấu trúc</h1>
<p>Trie là một cấu trúc dữ liệu dạng cây dùng để lưu trữ một danh sách các xâu với bộ kí tự hữu hạn, cho phép việc lưu trữ các xâu hiệu quả có tiền tố giống nhau.</p>
<p>Hãy xem xét một ví dụ sau:</p>
<center>
<img src="https://vnoi.info/wiki/uploads/trie_img1.png" />
</center>
<p>Trong một trie, mỗi cạnh được biểu diễn bằng một kí tự, mỗi đỉnh và đường đi từ gốc đến đỉnh đó biểu diễn một xâu gồm các kí tự thuộc các cạnh trên đường đi đó. Ví dụ, đỉnh $5$ biểu diễn xâu <code>ab</code>, đỉnh $10$ biểu diễn xâu <code>caa</code>.</p>
<p>Cấu trúc của trie rất dễ hiểu và cài đặt. Gọi <code>child(u, c)</code> là đỉnh con của đỉnh $u$ được nối bởi cạnh được biểu diễn bằng kí tự $c$, hoặc bằng $-1$ nếu đỉnh con đó không tồn tại. Xâu được thể hiện bởi đỉnh con này sẽ chính là xâu được thể hiện bởi đỉnh $u$, thêm kí tự $c$ vào cuối. Do vậy, ta chỉ cần mảng <code>child</code> này với mỗi đỉnh để duy trì cấu trúc của trie. Ví dụ, trong ảnh trên, <code>child(1, 'b') = 5</code>, <code>child(3, 'c') = 9</code>, <code>child(11, 'b') = -1</code>.</p>
<h1 class="editable"><a class="anchor" id="cài-đặt" href="#cài-đặt"></a>Cài đặt</h1>
<p>Với cấu trúc dữ liệu trie, có hai cách cài đặt chính chính là sử dụng mảng và sử dụng con trỏ.</p>
<p>Nếu định nghĩa cấu trúc như phần trước, ta chỉ có thể thực hiện truy vấn thêm xâu vào tập hợp. Để thực hiện hai truy vấn còn lại, với mỗi đỉnh $u$ trong trie, ta lưu thêm hai biến:</p>
<ul>
<li>
<code>exist</code>: có bao nhiêu xâu là xâu được thể hiện bởi đỉnh $u$</li>
<li>
<code>cnt</code>: có bao nhiêu xâu có tiền tố là xâu được thể hiện bởi đỉnh $u$.</li>
</ul>
<p><strong>Lưu ý</strong>: Tuy nhiên với từng bài toán, hai biến này có thể không cần thiết và có thể bỏ đi.</p>
<p>Với hàm thêm xâu vào trie, ta bắt đầu tại nút gốc. Ta duyệt qua lần lượt các kí tự trong xâu và đi xuống cạnh chứa kí tự tương ứng. Nếu như cạnh tương ứng đó chưa tồn tại thì ta tạo đỉnh mới rồi thêm nó vào mảng <code>child</code>. Dưới đây là ví dụ trie của tập hợp các xâu <code>aa</code>, <code>aba</code>, <code>ba</code>, <code>caaa</code>, <code>cab</code>, <code>cba</code>, <code>ca</code>.</p>
<center>
<img src="https://i.imgur.com/U31qYb0.gif" style="width:60%;" />
</center>
<p>Ở hàm xóa xâu, đầu tiên kiểm tra xâu đó có tồn tại trong trie hay không. Nếu có nhiều xâu như vậy, ta giảm giá trị <code>exist</code> của đỉnh tương ứng xâu đó đi một. Nếu không, ta sẽ đệ quy từ dưới lên trên để xóa dần các đỉnh dư thừa.</p>
<p>Hàm tìm xâu được cài đặt khá giống hàm thêm xâu. Chỉ khác là nếu không có cạnh tương ứng với kí tự đang duyệt, ta dừng ngay lập tức vì xâu đó sẽ không thể xuất hiện trong trie. Sau khi duyệt xong ta kiểm tra ở đỉnh đó có xâu nào kết thúc hay không, hay <code>exist != 0</code>.</p>
<h2 class="editable"><a class="anchor" id="cài-đặt-bằng-mảng" href="#cài-đặt-bằng-mảng"></a>Cài đặt bằng mảng</h2>
<pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">NUMBEROFNODES</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">struct</span> <span class="nc">Trie</span><span class="p">{</span>
    <span class="k">struct</span> <span class="nc">Node</span><span class="p">{</span>
        <span class="kt">int</span> <span class="n">child</span><span class="p">[</span><span class="mi">26</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">exist</span><span class="p">,</span> <span class="n">cnt</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">nodes</span><span class="p">[</span><span class="n">NUMBEROFNODES</span><span class="p">];</span>

    <span class="kt">int</span> <span class="n">cur</span><span class="p">;</span> <span class="c1">// Hiện trong trie đang có bao nhiêu đỉnh</span>
    <span class="n">Trie</span><span class="p">()</span> <span class="o">:</span> <span class="n">cur</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Tạo nút gốc cho Trie là đỉnh 0 khi khởi tạo Trie</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">child</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">child</span><span class="p">));</span>
        <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">exist</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="kt">int</span> <span class="n">new_node</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// Tạo và trả về giá trị của đỉnh mới được tạo ra</span>
        <span class="n">cur</span><span class="o">++</span><span class="p">;</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">child</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">child</span><span class="p">));</span>
        <span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">exist</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">cur</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">add_string</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">f</span> <span class="o">:</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">f</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Nếu cạnh tương ứng chữ cái c </span>
                                             <span class="c1">// chưa tồn tại thì ta tạo ra đỉnh mới</span>
                <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
            <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">cnt</span><span class="o">++</span><span class="p">;</span> <span class="c1">// Có thêm một xâu trong trie có tiền tố</span>
                              <span class="c1">// là xâu được thể hiện bằng đỉnh hiện tại</span>
        <span class="p">}</span>
        <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">exist</span><span class="o">++</span><span class="p">;</span> <span class="c1">// Đã tìm được đỉnh tương ứng với xâu s,</span>
                            <span class="c1">// ta tăng biến exist của đỉnh lên 1</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">delete_string_recursive</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Trả về liệu đỉnh pos</span>
                                                              <span class="c1">// có bị xóa đi hay không</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// Nếu chưa đến đỉnh tương ứng với xâu s</span>
                                  <span class="c1">// thì tiếp tục đệ quy xuống dưới</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
            <span class="kt">bool</span> <span class="n">isChildDeleted</span> <span class="o">=</span> <span class="n">delete_string_recursive</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">isChildDeleted</span><span class="p">)</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// Nếu đỉnh con tương ứng bị xóa thì</span>
                                                          <span class="c1">// ta gán lại đỉnh tương ứng bằng -1</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">exist</span><span class="o">--</span><span class="p">;</span> <span class="c1">// Nếu đã đến đỉnh tương ứng với xâu s</span>
                                 <span class="c1">// thì ta giảm biến exist của đỉnh đi 1</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Nếu đỉnh đang xét không phải gốc thì ta giảm biến cnt của đỉnh đi 1</span>
                        <span class="c1">// và kiểm tra đỉnh có bị xóa đi hay không</span>
                        <span class="c1">// Đỉnh bị xóa nếu không còn xâu nào đi qua nó, nói cách khác là</span>
                        <span class="c1">// không còn xâu nào có tiền tố là xâu được thể hiện bởi đỉnh pos</span>
            <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">cnt</span><span class="o">--</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">delete_string</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">find_string</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="c1">// Kiểm tra xâu s có trong</span>
                                             <span class="c1">// trie hay không</span>
        <span class="n">delete_string_recursive</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// Gọi hàm đệ quy xóa xâu s khỏi trie</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">find_string</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">f</span> <span class="o">:</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">f</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">exist</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// Kiểm tra có xâu nào</span>
                                        <span class="c1">// kết thúc tại đỉnh này hay không</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
<h2 class="editable"><a class="anchor" id="cài-đặt-bằng-con-trỏ" href="#cài-đặt-bằng-con-trỏ"></a>Cài đặt bằng con trỏ</h2>
<p>Gần như mọi phần trong đoạn code dưới hoạt động giống phần cài đặt bằng mảng nên sẽ không chú thích lại.</p>
<pre class="highlight"><code><span class="k">struct</span> <span class="nc">Trie</span><span class="p">{</span>
    <span class="k">struct</span> <span class="nc">Node</span><span class="p">{</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">child</span><span class="p">[</span><span class="mi">26</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">exist</span><span class="p">,</span> <span class="n">cnt</span><span class="p">;</span>

        <span class="n">Node</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="n">exist</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
 
    <span class="kt">int</span> <span class="n">cur</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">;</span>
    <span class="n">Trie</span><span class="p">()</span> <span class="o">:</span> <span class="n">cur</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">();</span>
    <span class="p">};</span>
 
    <span class="kt">void</span> <span class="n">add_string</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">f</span> <span class="o">:</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">f</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">();</span>

            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">exist</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">delete_string_recursive</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
            <span class="kt">bool</span> <span class="n">isChildDeleted</span> <span class="o">=</span> <span class="n">delete_string_recursive</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">isChildDeleted</span><span class="p">)</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">exist</span><span class="o">--</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="o">--</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">delete</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// Khác với cài đặt bằng mảng,</span>
                           <span class="c1">// ta có thể thực sự xóa đỉnh này đi</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="kt">void</span> <span class="n">delete_string</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">find_string</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

        <span class="n">delete_string_recursive</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
 
    <span class="kt">bool</span> <span class="n">find_string</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">f</span> <span class="o">:</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">f</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">exist</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
<h2 class="editable"><a class="anchor" id="ưu-và-nhược-điểm-của-cài-đặt-bằng-con-trỏ" href="#ưu-và-nhược-điểm-của-cài-đặt-bằng-con-trỏ"></a>Ưu và nhược điểm của cài đặt bằng con trỏ</h2>
<p>Ưu điểm:</p>
<ul>
<li>Không cần phải tính toán trước độ dài mảng cần dùng. Tuy có thể cài đặt trie bằng vector nhưng sẽ tốn thời gian truy cập hơn và đôi khi tốn nhiều bộ nhớ hơn.</li>
<li>Có thể tạo nhiều trie mà không lo tới bộ nhớ, phù hợp với các bài multitest.</li>
<li>Có thể xóa thực sự các đỉnh dư thừa.</li>
</ul>
<p>Nhược điểm:</p>
<ul>
<li>Dễ code sai nếu không thực sự hiểu con trỏ là gì.</li>
<li>Tùy thuộc vào compiler mà con trỏ có thể còn tốn nhiều bộ nhớ hơn dùng mảng.</li>
</ul>
<p>Trong phần còn lại của bài viết, tác giả sẽ ưu tiên cài đặt trie bằng mảng nếu được. Bạn đọc lưu ý xem tùy vào bài toán mà lựa chọn cách cài đặt phù hợp.</p>
<h1 class="editable"><a class="anchor" id="trie-nhị-phân" href="#trie-nhị-phân"></a>Trie nhị phân</h1>
<p>Có cấu trúc tương tự với trie đã giới thiệu ở phần trước (tạm gọi là trie xâu), trie nhị phân được dùng để xử lí một số bài toán liên quan tới thao tác bit. Một trie nhị phân bao gồm các cạnh là bit $0/1$ và các đỉnh là các số nguyên gồm các bit trên đường đi từ gốc đến nó.</p>
<p>Các số được thêm vào trie sẽ được chuyển thành dạng nhị phân rồi thêm các bit $0$ vào đầu sao cho độ dài các số nhị phân đều bằng nhau. Thông thường độ dài này sẽ được đặt là ${\log_2{(\max a_i)}}$ với $a_i$ là các số trong danh sách đã cho. Khi thêm vào trie, ta sẽ thêm các bit vào trie theo chiều từ trái sang phải.</p>
<p>Lưu ý rằng các ứng dụng của trie xâu (liệt kê bên dưới) đều có thể được áp dụng cho trie nhị phân.</p>
<center>
<img src="https://vnoi.info/wiki/uploads/trie_img2.png" />
</center>
<pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">NUMBEROFNODES</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">LG</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">struct</span> <span class="nc">Trie</span><span class="p">{</span>
    <span class="k">struct</span> <span class="nc">Node</span><span class="p">{</span>
        <span class="kt">int</span> <span class="n">child</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">exist</span><span class="p">,</span> <span class="n">cnt</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">nodes</span><span class="p">[</span><span class="n">NUMBEROFNODES</span><span class="p">];</span>

    <span class="kt">int</span> <span class="n">cur</span><span class="p">;</span>
    <span class="n">Trie</span><span class="p">()</span> <span class="o">:</span> <span class="n">cur</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">child</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">child</span><span class="p">));</span>
        <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">exist</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="kt">int</span> <span class="n">new_node</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">cur</span><span class="o">++</span><span class="p">;</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">child</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">child</span><span class="p">));</span>
        <span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">exist</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">cur</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">add_number</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">LG</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">();</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
            <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">exist</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">delete_number</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">find_number</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">LG</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>

            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
            <span class="n">nodes</span><span class="p">[</span><span class="n">tmp</span><span class="p">].</span><span class="n">cnt</span><span class="o">--</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">tmp</span><span class="p">].</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">pos</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">exist</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">find_number</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">LG</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">exist</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
<h1 class="editable"><a class="anchor" id="ứng-dụng" href="#ứng-dụng"></a>Ứng dụng</h1>
<p>Trie tuy trông đơn giản nhưng nó có rất nhiều ứng dụng khác nhau, xử lí các thao tác trên các danh sách số nguyên và danh sách xâu.</p>
<p>Trong đời sống, trie là nền tảng cho một số thứ chúng ta rất thân thuộc như các công cụ tìm kiếm(Google, Bing, …), tính năng tự động hoàn thành từ (autocomplete), … nhưng trong bài viết này sẽ tập trung vào các ứng dụng trong lập trình thi đấu.</p>
<h2 class="editable"><a class="anchor" id="sắp-xếp-một-danh-sách-các-xâu" href="#sắp-xếp-một-danh-sách-các-xâu"></a>Sắp xếp một danh sách các xâu</h2>
<h3 class="editable"><a class="anchor" id="bài-toán" href="#bài-toán"></a>Bài toán</h3>
<p>Cho một danh sách các xâu, hãy in ra các xâu đó theo thứ tự từ điển tăng dần.</p>
<h3 class="editable"><a class="anchor" id="lời-giải" href="#lời-giải"></a>Lời giải</h3>
<p>Sau khi xây dựng trie gồm các xâu trong danh sách, ta dfs một lượt qua trie đó, đi lần lượt các cạnh theo thứ tự chữ cái tăng dần. Duyệt tới một đỉnh tới bất kì, ta sẽ in ra các xâu được thể hiện bởi đỉnh đó nếu có. Dễ thấy ta sẽ lần lượt thu được các xâu trong danh sách theo thứ tự từ điển tăng dần.</p>
<p>Qua đó mà ta đạt được thuật toán sắp xếp một danh sách các xâu trong thời gian tuyến tính.</p>
<center>
<img src="https://i.imgur.com/xJ7Xrm8.gif" style="width:60%;" />
</center>
<pre class="highlight"><code><span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">current_string</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">exist</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">current_string</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">current_string</span> <span class="o">+=</span> <span class="kt">char</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="sc">'a'</span><span class="p">);</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">current_string</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
        <span class="n">current_string</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">sort_strings</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">current_string</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
    <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">current_string</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<h2 class="editable"><a class="anchor" id="xử-lí-truy-vấn-tiền-tố-chung-dài-nhất-của-hai-xâu" href="#xử-lí-truy-vấn-tiền-tố-chung-dài-nhất-của-hai-xâu"></a>Xử lí truy vấn tiền tố chung dài nhất của hai xâu</h2>
<h3 class="editable"><a class="anchor" id="bài-toán-1" href="#bài-toán-1"></a>Bài toán</h3>
<p>Cho một danh sách các xâu. Hãy trả lời các truy vấn tìm độ dài của tiền tố chung dài nhất của hai xâu bất kì trong danh sách đó.</p>
<h3 class="editable"><a class="anchor" id="lời-giải-1" href="#lời-giải-1"></a>Lời giải</h3>
<p>Đầu tiên, ta dựng một trie của danh sách các xâu đã cho.</p>
<p>Với hai xâu bất kì trong danh sách, ta có thể thấy tiền tố chung dài nhất của chúng cũng có thể được thể hiện bằng một đỉnh trong trie. Nhìn hình vẽ ta có dễ dàng nhận ra đỉnh cần tìm này cũng chính là tổ tiên chung thấp nhất của hai đỉnh thể hiện cho hai xâu đã cho.</p>
<p>Do vậy bài toán quy về xử lí truy vấn tìm tổ tiên chung thấp nhất của hai đỉnh bất kì trên cây, bạn đọc có thể tham khảo lời giải ở blog <a href="https://vnoi.info/wiki/algo/data-structures/lca-binlift.md">này</a>.</p>
<h2 class="editable"><a class="anchor" id="xử-lí-truy-vấn-tìm-xâu-có-thứ-tự-từ-điển-thứ-k" href="#xử-lí-truy-vấn-tìm-xâu-có-thứ-tự-từ-điển-thứ-k"></a>Xử lí truy vấn tìm xâu có thứ tự từ điển thứ k</h2>
<h3 class="editable"><a class="anchor" id="bài-toán-2" href="#bài-toán-2"></a>Bài toán</h3>
<p>Cho một danh sách các xâu. Xử lí các truy vấn tìm xâu có thứ tự từ điển lớn thứ $k$.</p>
<h3 class="editable"><a class="anchor" id="lời-giải-2" href="#lời-giải-2"></a>Lời giải</h3>
<p>Tương tự như bài toán trước, ta xây dựng một trie cho các xâu trong danh sách đã cho.</p>
<p>Ta tham khảo hàm tìm đáp án dưới đây:</p>
<pre class="highlight"><code><span class="n">string</span> <span class="nf">find_kth_string</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">res</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">exist</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="n">k</span> <span class="o">-=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">exist</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">nxt</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">nxt</span><span class="p">].</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="kt">char</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="sc">'a'</span><span class="p">);</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">nxt</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">k</span> <span class="o">-=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">nxt</span><span class="p">].</span><span class="n">cnt</span><span class="p">;</span>
        <span class="p">}</span> 
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<p>Trong đoạn code, dễ thấy rằng ta xây dựng đáp án từ trái qua phải. Ở đỉnh hiện tại đang xét, ta sử dụng biến đếm $cnt$ ở mỗi đỉnh con để xác định kí tự tiếp theo của xâu đáp án là gì. Sau đó di chuyển xuống đỉnh con đó để tiếp tục tìm kí tự tiếp theo.</p>
<h2 class="editable"><a class="anchor" id="xử-lí-truy-vấn-tìm-xor-lớn-nhất-với-giá-trị-được-cho" href="#xử-lí-truy-vấn-tìm-xor-lớn-nhất-với-giá-trị-được-cho"></a>Xử lí truy vấn tìm XOR lớn nhất với giá trị được cho</h2>
<p>Đây là một bài toán điển hình sử dụng trie nhị phân. Đa số các bài toán liên quan tới thao tác bit sử dụng trie đều là biến thể của bài toán này.</p>
<h3 class="editable"><a class="anchor" id="bài-toán-3" href="#bài-toán-3"></a>Bài toán</h3>
<p>Cho danh sách các số nguyên không âm $a_1, a_2, \ldots, a_n$. Xử lí các truy vấn cho số nguyên không âm $x$, tìm $\max_{i = 1}^{n} a_i \oplus x$ với $\oplus$ là <a href="https://en.wikipedia.org/wiki/Exclusive_or">phép XOR</a> hai số nguyên không âm.</p>
<h3 class="editable"><a class="anchor" id="lời-giải-3" href="#lời-giải-3"></a>Lời giải</h3>
<p>Đầu tiên xây dựng một trie nhị phân với các số nguyên đã cho.</p>
<p>Xét lần lượt các bit từ lớn đến bé của đáp án. Coi bit đang xét là bit thứ $i$. Ta sẽ xây dựng đáp án một cách tham lam bằng cách cố gắng đặt bit thứ $i$ của đáp án là $1$ do $2^i &gt; \sum_{i = 0}^{j - 1}2^j$. Nói cách khác, dù đặt cả $i - 1$ bit còn lại của đáp án là $1$ thì cũng không có lợi bằng đặt bit $i$ là $1$.</p>
<p>Ta sẽ lần lượt xây đáp án bằng các đi xuống từ gốc của trie. Coi ta đang xây bit thứ $i$ của đáp án. Nếu đỉnh hiện tại đang xét có thể đi xuống cạnh có bit là $f(x, i) \oplus 1$ với $f(x, i)$ là bit thứ $i$ của số $x$, ta sẽ đi qua cạnh đó để có được bit $i$ trong đáp án là $1$. Nếu không, ta "đành" đi xuống cạnh còn lại của đỉnh đang xét và có được bit $i$ của đáp án là $0$.</p>
<center>
<img src="https://vnoi.info/wiki/uploads/trie_img3.png" />
</center>
<pre class="highlight"><code><span class="kt">int</span> <span class="nf">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">LG</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1ll</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span> <span class="o">^</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<h1 class="editable"><a class="anchor" id="áp-dụng" href="#áp-dụng"></a>Áp dụng</h1>
<p>Dưới đây sẽ là một số bài toán hay (theo góc nhìn của người viết) và lời giải dễ hiểu sử dụng cấu trúc dữ liệu trie.</p>
<h2 class="editable"><a class="anchor" id="codeforces-kuro-and-gcd-and-xor-and-sum" href="#codeforces-kuro-and-gcd-and-xor-and-sum"></a>Codeforces - <a href="https://codeforces.com/problemset/problem/979/D">Kuro and GCD and XOR and SUM</a>
</h2>
<h3 class="editable"><a class="anchor" id="đề-bài" href="#đề-bài"></a>Đề bài</h3>
<p>Cho mảng số $a$ ban đầu rỗng. Xử lí $q$ truy vấn thuộc hai loại sau:</p>
<ul>
<li>$1\,u_i$: Thêm số $u_i$ vào mảng $a$.</li>
<li>$2\,x_i\,k_i\,s_i$: Tìm số $v$ thuộc mảng $a$ sao cho $GCD(x_i, v)$ chia hết cho $k_i$, $x_i + v \le s_i$, và $x_i \oplus v$ là lớn nhất có thể với $GCD(a, b)$ là ước chung lớn nhất của $a$ và $b$. In ra $-1$ nếu không có số $v$ nào trong mảng $a$ thỏa mãn.</li>
</ul>
<p>Giới hạn:</p>
<ul>
<li>$2 \le q \le 10^5$</li>
<li>$1 \le u_i, x_i, k_i, s_i \le 10^5$</li>
</ul>
<h3 class="editable"><a class="anchor" id="lời-giải-4" href="#lời-giải-4"></a>Lời giải</h3>
<p>Nhìn thấy bài toán tìm $x_i \oplus v$ lớn nhất ngay lập tức gợi cho chúng ta lời giải sử dụng trie để giải. Vì vậy ta sẽ cố gắng thiết kế trie để truy vấn trên tập các số thỏa mãn hai điều kiện còn lại.</p>
<p>Để $GCD(x_i, v)$ chia hết cho $k_i$, dễ nhận thấy cả $x_i$ và $v$ đều phải chia hết cho $k_i$. Do vậy, ta sẽ tạo $10^5$ trie, với trie thứ $i$ là các số trong mảng $a$ chia hết cho $i$. Để $x_i + v \le s_i$ thì dĩ nhiên $v \le s_i - x_i$, ta lưu với mỗi đỉnh trong trie số bé nhất trong cây con của đỉnh đó là bao nhiêu.</p>
<p>Vậy để giải quyết một truy vấn, ta sẽ tìm giá trị XOR lớn nhất trên trie thứ $k_i$ (cách giải đã trình bày ở <a href="#X%E1%BB%AD-l%C3%AD-truy-v%E1%BA%A5n-t%C3%ACm-XOR-l%E1%BB%9Bn-nh%E1%BA%A5t-v%E1%BB%9Bi-gi%C3%A1-tr%E1%BB%8B-%C4%91%C6%B0%E1%BB%A3c-cho">trên</a>) và chỉ đi vào một đỉnh con nếu như giá trị bé nhất của cây con đó bé hơn hoặc bằng $s_i - x_i$.</p>
<details>
<summary>Code mẫu</summary>
<pre class="highlight"><code><span class="cp">#include &lt;bits/stdc++.h&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">LG</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">INF</span> <span class="o">=</span> <span class="mf">1e9</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">Trie</span><span class="p">{</span>
    <span class="k">struct</span> <span class="nc">Node</span><span class="p">{</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">child</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">mn</span><span class="p">;</span>

        <span class="n">Node</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="n">mn</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="kt">int</span> <span class="n">cur</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">;</span>
    <span class="n">Trie</span><span class="p">()</span> <span class="o">:</span> <span class="n">cur</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">();</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="n">add_number</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">LG</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">();</span>

            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">mn</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mn</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">LG</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">c</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">c</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mn</span> <span class="o">&lt;=</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="p">((</span><span class="n">c</span> <span class="o">^</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">c</span> <span class="o">^</span> <span class="mi">1</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mn</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mf">1e5</span><span class="p">;</span>
<span class="n">Trie</span> <span class="n">tries</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>

<span class="kt">signed</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span> <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">i</span><span class="p">)</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">t</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">t</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">u</span><span class="p">;</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">u</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">x</span> <span class="o">:</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="n">tries</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">add_number</span><span class="p">(</span><span class="n">u</span><span class="p">);</span> 
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">s</span><span class="p">;</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">k</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"-1</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
            <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tries</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">query</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">}</span></code></pre>
</details>
<h2 class="editable"><a class="anchor" id="codeforces-vitya-and-strange-lesson" href="#codeforces-vitya-and-strange-lesson"></a>Codeforces - <a href="https://codeforces.com/problemset/problem/842/D">Vitya and Strange Lesson</a>
</h2>
<h3 class="editable"><a class="anchor" id="đề-bài-1" href="#đề-bài-1"></a>Đề bài</h3>
<p>Cho dãy số nguyên không âm $a_1, a_2, \ldots, a_n$ và $m$ truy vấn thuộc hai loại:</p>
<ul>
<li>Cho $x$, XOR tất cả các số trong dãy với $x$.</li>
<li>In ra MEX (số nguyên không âm nhỏ nhất mà không xuất hiện) của dãy.</li>
</ul>
<p>Giới hạn:</p>
<ul>
<li>$1 \le n, m \le 3 \times 10^5$</li>
<li>$0 \le a_i, x \le 3 \times 10^5$</li>
</ul>
<h3 class="editable"><a class="anchor" id="lời-giải-5" href="#lời-giải-5"></a>Lời giải</h3>
<p>Với các truy vấn loại $1$, thay vì thay đổi cả dãy, ta nhận thấy rằng $(a \oplus b) \oplus c = a \oplus (b \oplus c)$. Tức là nếu áp dụng hai truy vấn loại $1$ với hai số nguyên $b, c$ thì cũng tương tự như áp dụng một truy vấn với số nguyên $b \oplus c$. Do vậy, ta chỉ cần duy trì cả dãy đang bị XOR bởi số nguyên nào. Gọi số đó là $z$.</p>
<p>Giả dụ ta đã có một trie nhị phân của dãy số $a_1, a_2, \ldots, a_n$ và ta muốn tìm MEX của các số trong đó. Ta sẽ sử dụng thuật toán tương tự chặt nhị phân. Gọi độ cao của trie là $k$. Khởi đầu tại gốc trie, ta kiểm tra xem cây con bên trái (cạnh thể hiện bit $0$) có phải là cây nhị phân hoàn hảo hay không. Nói cách khác, tất cả các số trong khoảng $[0, 2^k - 1]$ có tồn tại hay không. Nếu có, ta chắc chắn MEX của dãy số nằm trong khoảng này. Nếu không, ta chắc chắn MEX của dãy số nằm trong khoảng $[2^k, 2^{k + 1} - 1]$. Sau đó, ta đi xuống đỉnh con tương ứng và tiếp tục xét hai đỉnh con của nó. Làm như vậy với tất cả các bit là sẽ tìm được đáp án.</p>
<center>
<img src="https://vnoi.info/wiki/uploads/trie_img4.png" />
</center>
<p>Vậy phần còn lại phải xử lí là kết hợp thuật tìm MEX trên với việc cả mảng đang bị XOR bởi số $z$. Dễ nhận thấy là, nếu bit thứ $k$ của $z$ được bật, thì nó tương tự việc hai cây con trái và phải của đỉnh đang xét được đổi chỗ cho nhau. Vì vậy thuật toán cuối cùng tương tự với thuật toán tìm MEX trên, thêm việc xét bit thứ $k$ của $z$ mà ta sẽ xét cây con trái trước (nếu bit đó là $0$) hay cây con phải trước (nếu bit đó là $1$).</p>
<details>
<summary>Code mẫu</summary>
<pre class="highlight"><code><span class="cp">#include &lt;bits/stdc++.h&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">NUMBEROFNODES</span> <span class="o">=</span> <span class="mi">5400005</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">LG</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">Trie</span><span class="p">{</span>
    <span class="k">struct</span> <span class="nc">Node</span><span class="p">{</span>
        <span class="kt">int</span> <span class="n">child</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">nodes</span><span class="p">[</span><span class="n">NUMBEROFNODES</span><span class="p">];</span>

    <span class="kt">int</span> <span class="n">cur</span><span class="p">;</span>
    <span class="n">Trie</span><span class="p">()</span> <span class="o">:</span> <span class="n">cur</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">child</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">child</span><span class="p">));</span>
        <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="kt">int</span> <span class="n">new_node</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">cur</span><span class="o">++</span><span class="p">;</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">child</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">child</span><span class="p">));</span>
        <span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">cur</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">add_number</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">LG</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">();</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
            <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">LG</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">nodes</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]].</span><span class="n">cnt</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span> <span class="o">^</span> <span class="mi">1</span><span class="p">];</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">signed</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    
    <span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span> <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>

    <span class="n">Trie</span> <span class="n">trie</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">()),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">x</span> <span class="o">:</span> <span class="n">v</span><span class="p">)</span> <span class="n">trie</span><span class="p">.</span><span class="n">add_number</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">cur_xor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">m</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">cur_xor</span> <span class="o">^=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">trie</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">cur_xor</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">}</span></code></pre>
</details>
<h2 class="editable"><a class="anchor" id="codechef-english" href="#codechef-english"></a>Codechef - <a href="https://www.codechef.com/problems-old/ENGLISH">English</a>
</h2>
<h3 class="editable"><a class="anchor" id="đề-bài-2" href="#đề-bài-2"></a>Đề bài</h3>
<p>Cho $N$ xâu $W_1, W_2, \ldots, W_N$. Một cặp xâu có độ dài tiền tố chung dài nhất là $l_p$, độ dài hậu tố chung dài nhất là $l_s$, thì vẻ đẹp của cặp xâu đó là là $\min(l_p, l_s)^2$. Hãy ghép cặp các xâu, mỗi xâu nằm trong tối đa một cặp sao cho tổng vẻ đẹp các cặp xâu là lớn nhất.</p>
<p>Giới hạn:</p>
<ul>
<li>$1 \le N \le 10^5$</li>
<li>$1 \le \lvert W_i \rvert \le 10^5$</li>
<li>$1 \le \sum^N_{i = 1} \lvert W_i \rvert \le 10^5$</li>
</ul>
<h3 class="editable"><a class="anchor" id="lời-giải-6" href="#lời-giải-6"></a>Lời giải</h3>
<p>Giả sử bài toán định nghĩa vẻ đẹp một cặp xâu là $l_p^2$, thì bài toán có thể dễ dàng được giải quyết bằng cách dfs trên trie các xâu đã cho.</p>
<p>Tuy nhiên, vì đề bài định nghĩa vẻ đẹp một cặp xâu là $\min(l_p, l_s)^2$, ta cần một cách nào đó để so sánh cả tiền tố và hậu tố cùng một lúc trên trie. Ta có thể làm điều này bằng cách biến đổi các xâu $W$. Chính xác hơn, nếu $W = C_1C_2 \ldots C_M$ thì ta biến đổi $W = (C_1, C_M)(C_2, C_{M - 1}) \ldots (C_M, C_1)$ với $(C_1, C_M)$ là "kí tự" đầu tiên. Nói cách khác, ta thay đổi bảng chữ cái từ $26$ kí tự thành bảng chữ cái có $676$ kí tự $(a, a), (a, b), \ldots, (z, z)$.</p>
<p>Từ đó ta có thể thấy bài toán đã trở thành một cặp xâu có vẻ đẹp là $l_p^2$. Cách tính đáp án chi tiết bạn đọc có thể tham khảo trong code mẫu.</p>
<details>
<summary>Code mẫu</summary>
<pre class="highlight"><code><span class="cp">#include &lt;bits/stdc++.h&gt;
</span>
<span class="cp">#define ll long long
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">ll</span> <span class="nf">sqr</span><span class="p">(</span><span class="n">ll</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">Trie</span><span class="p">{</span>
    <span class="k">struct</span> <span class="nc">Node</span><span class="p">{</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">child</span><span class="p">[</span><span class="mi">26</span><span class="p">][</span><span class="mi">26</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>

        <span class="n">Node</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
 
    <span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">;</span>
    <span class="n">Trie</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">();</span>
    <span class="p">};</span>
 
    <span class="kt">void</span> <span class="n">add_string</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">c1</span><span class="p">][</span><span class="n">c2</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">c1</span><span class="p">][</span><span class="n">c2</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">();</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">c1</span><span class="p">][</span><span class="n">c2</span><span class="p">];</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ll</span> <span class="n">solve</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ll</span> <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">root</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="p">(</span><span class="n">ll</span><span class="p">)(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">sqr</span><span class="p">(</span><span class="n">depth</span><span class="p">)</span> <span class="o">-</span> <span class="n">sqr</span><span class="p">(</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c1</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">c1</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c2</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">c2</span><span class="o">++</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">c1</span><span class="p">][</span><span class="n">c2</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">solve</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">c1</span><span class="p">][</span><span class="n">c2</span><span class="p">],</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">signed</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    
    <span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span> <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">t</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">t</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">t</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Trie</span> <span class="n">trie</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">string</span> <span class="n">s</span><span class="p">;</span> 
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
            <span class="n">trie</span><span class="p">.</span><span class="n">add_string</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">trie</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">trie</span><span class="p">.</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">}</span></code></pre>
</details>
<h2 class="editable"><a class="anchor" id="joi-open-contest-2016-selling-rna-strands" href="#joi-open-contest-2016-selling-rna-strands"></a>JOI Open Contest 2016 - <a href="https://oj.uz/problem/view/JOI16_selling_rna">Selling RNA Strands</a>
</h2>
<h3 class="editable"><a class="anchor" id="đề-bài-3" href="#đề-bài-3"></a>Đề bài</h3>
<p>Cho danh sách $N$ xâu $S_1, S_2, \ldots, S_N$ và $M$ truy vấn. Truy vấn thứ $j$ gồm hai xâu $P_j$ và $Q_j$, hãy tìm số lượng xâu trong danh sách ban đầu có tiền tố là $P_j$ và hậu tố là $Q_j$.</p>
<p>Giới hạn:</p>
<ul>
<li>$1 \le N, M, \lvert S_i \rvert, \lvert P_j \rvert, \lvert Q_j \rvert \le 10^5$</li>
<li>$1 \le \sum^{N}_{i = 1} \lvert S_i \rvert \le 2 \times 10^6$.</li>
<li>$1 \le \sum^{N}_{i = 1} \lvert P_j \rvert \le 2 \times 10^6$.</li>
<li>$1 \le \sum^{N}_{i = 1} \lvert Q_j \rvert \le 2 \times 10^6$.</li>
<li>Các xâu chỉ gồm các kí tự <code>A</code>, <code>G</code>, <code>C</code>, <code>U</code>.</li>
</ul>
<h3 class="editable"><a class="anchor" id="lời-giải-7" href="#lời-giải-7"></a>Lời giải</h3>
<p>Đầu tiên, ta sắp xếp và đánh số lại các xâu theo thứ tự từ điển tăng dần.</p>
<p>Xây một trie cho $N$ xâu đó. Không khó để nhận ra rằng với mỗi đỉnh trie này, nó tương ứng với tiền tố của một đoạn <strong>liên tiếp</strong> $[l, r]$ các xâu này. Ta sẽ lưu trên mỗi đỉnh hai giá trị $l, r$ có ý nghĩa như trên.</p>
<p>Xây một trie thứ hai cũng cho $N$ xâu này nhưng bị đảo ngược, tức mỗi đỉnh trên trie đó tương ứng với một hậu tố của một (hoặc nhiều) xâu nào đó. Với mỗi đỉnh trên trie, ta lưu một vector chứa thứ tự của các xâu có hậu tố là xâu thể hiện bởi đỉnh đó. Lưu ý không thể lưu $l, r$ như trie trước do nó có thể không liên tiếp vì ta đã đảo ngược các xâu.</p>
<p>Với mỗi truy vấn $j$, ta tìm đỉnh trên trie thứ nhất thể hiện cho tiền tố $P_j$ và có được khoảng liên tiếp các xâu có tiền tố này. Tiếp theo, ta tìm đỉnh trên trie thứ hai thể hiện cho hậu tố $Q_j$ và có được vector chứa các xâu có hậu tố này. Tại đây, bài toán quy trở về cho một vector các số, tìm số số nằm trong khoảng $[l, r]$. Bài toán này có thể dễ dàng được giải quyết bằng thuật toán chặt nhị phân.</p>
<details>
<summary>Code mẫu</summary>
<pre class="highlight"><code><span class="cp">#include &lt;bits/stdc++.h&gt;
</span> 
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
 
<span class="kt">int</span> <span class="nf">get_val</span><span class="p">(</span><span class="kt">char</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="sc">'A'</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="sc">'G'</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="sc">'C'</span><span class="p">)</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">char</span> <span class="nf">get_char</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="sc">'A'</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="sc">'G'</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="sc">'C'</span><span class="p">;</span>
    <span class="k">return</span> <span class="sc">'U'</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="k">const</span> <span class="kt">int</span> <span class="n">NUMBEROFNODES</span> <span class="o">=</span> <span class="mf">2e6</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">INF</span> <span class="o">=</span> <span class="mf">1e9</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">Trie</span><span class="p">{</span>
    <span class="k">struct</span> <span class="nc">Node</span><span class="p">{</span>
        <span class="kt">int</span> <span class="n">child</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">exist</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">nodes</span><span class="p">[</span><span class="n">numberOfNodes</span><span class="p">];</span>
 
    <span class="kt">int</span> <span class="n">cur</span><span class="p">;</span>
    <span class="n">Trie</span><span class="p">()</span> <span class="o">:</span> <span class="n">cur</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">child</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">child</span><span class="p">));</span>
        <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">l</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">INF</span><span class="p">;</span>
        <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">exist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>
 
    <span class="kt">int</span> <span class="n">new_node</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">cur</span><span class="o">++</span><span class="p">;</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">child</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">child</span><span class="p">));</span>
        <span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">l</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span> <span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">INF</span><span class="p">;</span>
        <span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">exist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">cur</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="kt">void</span> <span class="n">add_string</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">f</span> <span class="o">:</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">get_val</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">();</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
 
            <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">l</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">l</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
            <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">r</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">r</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">exist</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">get_range</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">f</span> <span class="o">:</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">get_val</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">l</span><span class="p">,</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">r</span><span class="p">};</span>
    <span class="p">}</span>
 
    <span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">current_string</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">exist</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">current_string</span><span class="p">);</span>
 
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">current_string</span> <span class="o">+=</span> <span class="n">get_char</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">current_string</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
            <span class="n">current_string</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
 
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">sort_strings</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">string</span> <span class="n">current_string</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">current_string</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
 
<span class="k">struct</span> <span class="nc">ReversedTrie</span><span class="p">{</span>
    <span class="k">struct</span> <span class="nc">Node</span><span class="p">{</span>
        <span class="kt">int</span> <span class="n">child</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ids</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">nodes</span><span class="p">[</span><span class="n">NUMBEROFNODES</span><span class="p">];</span>
 
    <span class="kt">int</span> <span class="n">cur</span><span class="p">;</span>
    <span class="n">ReversedTrie</span><span class="p">()</span> <span class="o">:</span> <span class="n">cur</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">child</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">child</span><span class="p">));</span>
        <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ids</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="p">};</span>
 
    <span class="kt">int</span> <span class="n">new_node</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">cur</span><span class="o">++</span><span class="p">;</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">child</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">child</span><span class="p">));</span>
        <span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">ids</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">cur</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="kt">void</span> <span class="n">add_string</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">reverse</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">f</span> <span class="o">:</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">get_val</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">();</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
            <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">ids</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
 
    <span class="kt">int</span> <span class="n">query</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">range</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">reverse</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">f</span> <span class="o">:</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">get_val</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
        <span class="p">}</span>
 
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">ids</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">ids</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">range</span><span class="p">.</span><span class="n">first</span><span class="p">)</span> <span class="o">-</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">ids</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">upper_bound</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">ids</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">ids</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">range</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="o">-</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">ids</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
 
        <span class="k">return</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
 
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">sort_strings</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Trie</span> <span class="n">list</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">s</span> <span class="o">:</span> <span class="n">v</span><span class="p">)</span> <span class="n">list</span><span class="p">.</span><span class="n">add_string</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">list</span><span class="p">.</span><span class="n">sort_strings</span><span class="p">();</span>
<span class="p">}</span>
 
<span class="kt">signed</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    
    <span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span> <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
 
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
 
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
        <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">sort_strings</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
 
    <span class="n">Trie</span> <span class="n">trie1</span><span class="p">;</span>
    <span class="n">ReversedTrie</span> <span class="n">trie2</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">trie1</span><span class="p">.</span><span class="n">add_string</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">trie2</span><span class="p">.</span><span class="n">add_string</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
 
    <span class="k">while</span> <span class="p">(</span><span class="n">m</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">p</span> <span class="o">&gt;&gt;</span> <span class="n">q</span><span class="p">;</span>
 
        <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">range</span> <span class="o">=</span> <span class="n">trie1</span><span class="p">.</span><span class="n">get_range</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"0</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">trie2</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">range</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">}</span></code></pre>
</details>
<h2 class="editable"><a class="anchor" id="xx-open-cup-grand-prix-of-kazan-bitwise-xor" href="#xx-open-cup-grand-prix-of-kazan-bitwise-xor"></a>XX Open Cup, Grand Prix of Kazan - <a href="https://codeforces.com/gym/102331/problem/B">Bitwise Xor</a>
</h2>
<h3 class="editable"><a class="anchor" id="đề-bài-4" href="#đề-bài-4"></a>Đề bài</h3>
<p>Cho dãy số nguyên $a_1, a_2, \ldots, a_N$ và số nguyên $x$. Đếm số dãy con $1 \le b_1 &lt; b_2 &lt; \ldots &lt; b_k \le n$ mà $a_{b_i} \oplus a_{b_j} \ge x$ với mọi cặp $(i, j)$ thỏa mãn $1 \le i &lt; j \le k$.</p>
<p>Giới hạn:</p>
<ul>
<li>$1 \le N \le 3 \times 10^5$</li>
<li>$0 \le a_i, x &lt; 2^{60}$</li>
</ul>
<h3 class="editable"><a class="anchor" id="lời-giải-8" href="#lời-giải-8"></a>Lời giải</h3>
<p>Với một dãy số ${x_1, x_2, \ldots, x_k}$ thỏa mãn điều kiện đề bài, nhận thấy rằng nếu ta sắp xếp lại các giá trị đó từ bé đến lớn, thì giá trị bé nhất của $x_i \oplus x_j$ sẽ có $\lvert i - j \rvert = 1$. Phần chứng minh xin dành cho bạn đọc.</p>
<p>Vì vậy, ta có thể sắp xếp lại mảng $a$ tăng dần, và đếm số dãy $b$ thỏa mãn. Một công thức quy hoạch động với độ phức tạp $\mathcal{O}(n^2)$ khá dễ để thấy. Gọi $dp[i]$ là số dãy $b$ thỏa mãn với $b_k = i$, thì $dp[i] = \sum^{i - 1}_{j = 1,\,a_i \oplus a_j \ge x} dp[j]$.</p>
<p>Công thức quy hoạch động này có thể được tối ưu sử dụng một trie nhị phân. Giả dụ xét bit thứ $i$, với $i - 1$ bit đầu tiên của $a_i \oplus a_j$ bằng $i - 1$ bit đầu tiên của $x$, ta chia hai trường hợp:</p>
<ul>
<li>Bit thứ $i$ của $x$ là $1$: Bit thứ $i$ của $a_i \oplus a_j$ cũng phải bằng $1$. Ta đi xuống cây con tương ứng bit $1$ để xét bit thứ $i + 1$.</li>
<li>Bit thứ $i$ của $x$ là $0$: Bit thứ $i$ của $a_i \oplus a_j$ có thể là $0$ hoặc $1$. Nếu là $1$ thì các bit còn lại ta điền gì cũng vẫn thỏa mãn $a_i \oplus a_j \ge x$, tức có thể lấy tổng tất cả giá trị $dp$ trong cây con tương ứng bit $1$. Rồi ta đi xuống cây con tương ứng bit $0$ để xét bit thứ $i + 1$.</li>
</ul>
<p>Dựa vào bit thứ $i$ của $a_i \oplus a_j$ và giá trị của $a_i$ ta hoàn toán có thể tính được bit thứ $i$ của $a_j$. Lưu ý mọi dãy con gồm $1$ phần tử đều thỏa mãn điều kiện của đề bài.</p>
<p>Lúc này, bạn đọc có thể tưởng tượng trie như một <a href="https://vnoi.info/wiki/algo/data-structures/segment-tree-basic.md">cây phân đoạn</a>, truy vấn trên trie y hệt như truy vấn như cây phân đoạn nhưng điều kiện đi xuống cây con bên nào bị thay đổi.</p>
<details>
<summary>Code mẫu</summary>
<pre class="highlight"><code><span class="cp">#include &lt;bits/stdc++.h&gt;
</span>
<span class="cp">#define ll long long
</span> 
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">MOD</span> <span class="o">=</span> <span class="mi">998244353</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">a</span> <span class="o">+=</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">MOD</span><span class="p">)</span> <span class="n">a</span> <span class="o">-=</span> <span class="n">MOD</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="k">const</span> <span class="kt">int</span> <span class="n">NUMBEROFNODES</span> <span class="o">=</span> <span class="mi">18000005</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">LG</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">Trie</span><span class="p">{</span>
    <span class="k">struct</span> <span class="nc">Node</span><span class="p">{</span>
        <span class="kt">int</span> <span class="n">child</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">sum</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">nodes</span><span class="p">[</span><span class="n">NUMBEROFNODES</span><span class="p">];</span>
 
    <span class="kt">int</span> <span class="n">cur</span><span class="p">;</span>
    <span class="n">Trie</span><span class="p">()</span> <span class="o">:</span> <span class="n">cur</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">child</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">child</span><span class="p">));</span>
        <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>
 
    <span class="kt">int</span> <span class="n">new_node</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">cur</span><span class="o">++</span><span class="p">;</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">child</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">child</span><span class="p">));</span>
        <span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">cur</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="kt">void</span> <span class="n">add_value</span><span class="p">(</span><span class="n">ll</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">LG</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">();</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
            <span class="n">add</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">sum</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
 
    <span class="kt">int</span> <span class="n">query</span><span class="p">(</span><span class="n">ll</span> <span class="n">x</span><span class="p">,</span> <span class="n">ll</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">LG</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">c1</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">c2</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">c2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c1</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c1</span> <span class="o">^</span> <span class="mi">1</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c1</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">add</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">nodes</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c1</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]].</span><span class="n">sum</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">child</span><span class="p">[</span><span class="n">c1</span><span class="p">];</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">add</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">nodes</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">sum</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mf">3e5</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="n">ll</span> <span class="n">k</span><span class="p">;</span>
<span class="n">ll</span> <span class="n">a</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
 
<span class="kt">signed</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    
    <span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span> <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
 
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">k</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

    <span class="n">Trie</span> <span class="n">trie</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">trie</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">k</span><span class="p">);</span>
        <span class="n">trie</span><span class="p">.</span><span class="n">add_value</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">val</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">add</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">res</span><span class="p">;</span>
    
<span class="p">}</span></code></pre>
</details>
<h1 class="editable"><a class="anchor" id="bài-tập" href="#bài-tập"></a>Bài tập</h1>
<p><a href="https://oj.vnoi.info/tags/?tag_id=trie">VNOJ Tag Problem List</a></p>
<h2 class="editable"><a class="anchor" id="trie-xâu" href="#trie-xâu"></a>Trie xâu</h2>
<p><a href="https://www.spoj.com/problems/ADAINDEX/">SPOJ - Ada and Indexing</a> (Dễ)</p>
<p><a href="https://www.spoj.com/problems/TRYCOMP/">SPOJ - Try to complete</a> (Dễ)</p>
<p><a href="https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103752/problem/A">IOI 2008 - Type Printer</a> (Dễ)</p>
<p><a href="https://www.codechef.com/problems/NPLFLF">Codechef - Query On Strings</a> (Dễ)</p>
<p><a href="https://codeforces.com/gym/101628/problem/K">Codeforces Gym - Know Your Statement</a> (Trung bình)</p>
<p><a href="https://www.codechef.com/problems/RJSTRING">Codechef - Paisa Double</a> (Trung bình)</p>
<p><a href="https://oj.vnoi.info/problem/voi21_bonus">VOI 2021 - Phần thưởng</a> (Trung bình)</p>
<p><a href="https://atcoder.jp/contests/arc087/tasks/arc087_c">Atcoder - Prefix-tree Game</a> (Khó)</p>
<p><a href="https://oj.vnoi.info/problem/pvhoi22_5_lcp">PVHOI 2.2 - Tiền tố chung dài nhất</a> (Khó)</p>
<h2 class="editable"><a class="anchor" id="trie-nhị-phân-1" href="#trie-nhị-phân-1"></a>Trie nhị phân</h2>
<p><a href="https://www.hackerrank.com/challenges/xor-key/problem">Hackerrank - XOR Key</a> (Dễ)</p>
<p><a href="https://www.spoj.com/problems/SUBXOR/">SPOJ - SubXor</a> (Dễ)</p>
<p><a href="https://www.spoj.com/problems/XORX/">SPOJ - x-Xor It!</a> (Dễ)</p>
<p><a href="https://csacademy.com/contest/round-42/task/xor-submatrix/statement/">CSAcademy - Xor Submatrix</a> (Trung bình)</p>
<p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=6964">HDU - I love counting</a> (Trung bình)</p>
<p><a href="https://www.hackerrank.com/contests/w8/challenges/black-box-1/problem">Hackerrank - The Black Box</a> (Khó)</p>
<p><a href="https://dmoj.ca/problem/cco17p3">CCO 2017 - Vera and Modern Art</a> (Khó)</p>
</div>
</div>
</div>
</div>
