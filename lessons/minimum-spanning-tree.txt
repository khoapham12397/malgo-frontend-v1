<div id="wiki-content">
<h1 class="pt-4">Bài toán tìm cây khung nhỏ nhất trong đồ thị</h1>
<div class="breadcrumb"><nav aria-label="Breadcrumb"><ol>
<li class="breadcrumb-item"><a href="https://vnoi.info/wiki/gollum/overview/algo/">algo</a></li>
<li class="breadcrumb-item"><a href="https://vnoi.info/wiki/gollum/overview/algo/graph-theory/">graph-theory</a></li>
</ol></nav></div>
<div class>
<div id="wiki-body" class="gollum-markdown-content overflow-hidden ">
<div class="markdown-body ">
<p><strong>Tác giả</strong>:</p>
<ul>
<li>Hoàng Việt Cường - Đại học Bách Khoa Hà Nội</li>
<li>Phan Thành Long - THPT Chuyên Thái Bình (K17-20)</li>
</ul>
<p><strong>Reviewer</strong>:
Vương Hoàng Long - Đại học Quốc Gia Singapore</p>
<h2 class="editable"><a class="anchor" id="một-số-kiến-thức-cần-biết" href="#một-số-kiến-thức-cần-biết"></a>Một số kiến thức cần biết</h2>
<p>Vì bài viết nói về cây khung nhỏ nhất, các bạn nên đọc một số kiến thức liên quan đến cây trước mà mình liệt kê dưới đây vì đây là những kiến thức rất thường gặp trong những bài tập về cây khung, trong khuôn khổ bài viết mình sẽ không giải thích lại về những kiến thức này nữa:</p>
<ul>
<li><a href="https://vnoi.info/wiki/translate/topcoder/Range-Minimum-Query-and-Lowest-Common-Ancestor.md#b%C3%A0i-to%C3%A1n-lowest-common-ancestor-lca">Lowest Common Accessor</a></li>
<li><a href="https://vnoi.info/wiki/algo/data-structures/disjoint-set.md">Disjoin Set Union</a></li>
</ul>
<p><strong>Lưu ý:</strong> Toàn bộ phần code phía dưới sử dụng cho <code>C++11</code> trở lên, các bạn lưu ý kiểm tra trình biên dịch của mình.</p>
<h2 class="editable"><a class="anchor" id="cây-khung-nhỏ-nhất-là-gì" href="#cây-khung-nhỏ-nhất-là-gì"></a>Cây khung nhỏ nhất là gì</h2>
<h3 class="editable"><a class="anchor" id="định-nghĩa" href="#định-nghĩa"></a>Định nghĩa</h3>
<p>Theo lý thuyết đồ thị, chúng ta đều biết rằng 1 đồ thị được biểu diễn bằng công thức $G = (V, E)$, trong đó đồ thị $G$ của chúng ta bao gồm tập các đỉnh $V$ và tập các cạnh $E$.</p>
<ul>
<li>
<strong>Cây khung (<em>spanning tree</em>)</strong> của đồ thị là một tập hợp các cạnh của đồ thị thỏa mãn tập cạnh này <strong><em>không chứa chu trình</em></strong> và <strong><em>liên thông</em></strong> (từ một đỉnh bất kì có thể đi tới bất kỳ đỉnh nào khác theo mà chỉ dùng các cạnh trên <strong>cây khung</strong>)</li>
<li>
<p>Trong đồ thị <strong>có trọng số</strong>, <strong>cây khung nhỏ nhất (<em>minimum spanning tree</em>)</strong> là <strong>cây khung</strong> có tổng trọng số các cạnh trong cây <strong>nhỏ nhất</strong>.</p>
</li>
<li>
<p>Một ví dụ về cây khung trong đồ thị vô hướng không trọng số:
<img src="https://i.imgur.com/QqWCZO0.png" /></p>
</li>
<li>Một ví dụ về cây khung <strong>nhỏ nhất</strong> trong đồ thị vô hướng có trọng số:
<img src="https://i.imgur.com/egYfsfI.jpg" />
</li>
</ul>
<p>Trong khuôn khổ bài viết, chúng ta sẽ làm việc với <strong>đồ thị vô hướng có trọng số</strong>.</p>
<h3 class="editable"><a class="anchor" id="tính-chất" href="#tính-chất"></a>Tính chất</h3>
<p>Một vài tính chất của cây khung nhỏ nhất trong đồ thị vô hướng có trọng số:</p>
<ul>
<li>
<p><strong>1. Tính chất chu trình</strong>: Trong một chu trình $C$ bất kỳ, nếu $e$ là cạnh có trọng số lớn nhất <strong>tuyệt đối</strong> (không có cạnh nào có trọng số bằng $e$) thì $e$ không thể nằm trên bất kỳ cây khung nhỏ nhất nào.</p>
</li>
<li>
<p><strong>2. Đường đi hẹp nhất</strong>: Xét 2 đỉnh $u$, $v$ bất kỳ trong đồ thị. Nếu $w$ là trọng số của cạnh lớn nhất trên đường đi từ $u$ đến $v$ trên cây khung nhỏ nhất của đồ thị thì ta không thể tìm được đường đi nào từ $u$ đến $v$ trên đồ thị ban đầu chỉ đi qua những cạnh có trọng số nhỏ hơn $w$.</p>
</li>
<li>
<p><strong>3. Tính duy nhất</strong>: Nếu tất cả các cạnh đều có trọng số khác nhau thì chỉ có duy một cây khung nhỏ nhất. Ngược lại, nếu một vài cạnh có trọng số giống nhau thì có thể có nhiều hơn một cây khung nhỏ nhất.</p>
</li>
<li>
<p><strong>4. Tính chất cạnh nhỏ nhất</strong>: Nếu $e$ là cạnh có trọng số nhỏ nhất của đồ thị, và không có cạnh nào có trọng số bằng $e$ thì $e$ nằm trong mọi cây khung nhỏ nhất của đồ thị.</p>
</li>
</ul>
<h4 class="editable"><a class="anchor" id="chứng-minh" href="#chứng-minh"></a>Chứng minh</h4>
<blockquote>
<p><strong>Lưu ý :</strong> các bạn mới học cây khung lần đầu cân nhắc việc đọc chứng minh, tác giả khuyên các bạn nên tạm thời bỏ qua phần này</p>
</blockquote>
<p>Xuyên suốt cả bốn tính chất, ta đều sử dụng phép phản chứng để chứng minh</p>
<ul>
<li>
<strong>1. Tính chất chu trình</strong>:
Giả sử $e$ thuộc một cây khung $T$ của đồ thị, ta sẽ chứng minh luôn tồn tại một cây khung khác của đồ thị có trọng số nhỏ hơn $T$.
<ul>
<li>Ta thử xóa cạnh $e$ khỏi cây khung $T$. Lúc này, $T$ sẽ bị chia làm 2 thành phần liên thông và tổng trọng số giảm đi $w_e$.</li>
<li>Xét các đỉnh nằm trong chu trình $C$, giả sử sau khi xóa $e$ khỏi cây khung, các đỉnh này vẫn liên thông với nhau. Vì thế, khi thêm $e$ trở lại vào cây khung, $e$ sẽ kết nối 2 đỉnh đã liên thông với nhau $\Rightarrow$ tồn tại chu trình trong cây khung $\Rightarrow$ Trái với giả thiết $T$ là cây khung.
⇒ Vậy nên, khi xóa $e$ khỏi $T$, các đỉnh nằm trong chu trình $C$ sẽ bị tách làm 2 thành phần liên thông. Do đó, ta có thể chọn ra cạnh $e'$ khác $e$ thuộc chu trình $C$ để kết nối 2 thành liên thông này, biến $T$ trở lại thành một cây khung của đồ thị. Mặt khác, $e$ là cạnh có trọng số lớn nhất tuyệt đối trên $C$, nên khi thay $e$ bằng $e'$, trọng số của T sẽ giảm đi $w_e - w_{e'}$
<strong>Kết luận:</strong> T không phải là cây khung nhỏ nhất của đồ thị.</li>
</ul>
</li>
<li>
<strong>2. Đường đi hẹp nhất</strong>:
<ul>
<li>Xét cây khung nhỏ nhất $T$ bất kỳ của đồ thị $G$ mà tồn tại đường đi $u \rightarrow v$ trên $G$ có cạnh lớn nhất <strong>nhỏ hơn</strong> cạnh lớn nhất của đường đi $u \rightarrow v$ trên $T$.</li>
<li>Gọi đường đi $u \rightarrow v$ trên $G$ là $path$, cạnh lớn nhất của đường đi $u \rightarrow v$ trên $T$ là $e$.
⇒ Như vậy, nếu xóa $e$ khỏi cây khung ban đầu, cây khung sẽ bị chia thành 2 TPLT rời nhau, một TPLT chứa $u$ và TPLT còn lại chứa $v$.</li>
<li>Do $path$ là đường đi $u \rightarrow v$ trên $G$ nên trên $path$ sẽ tồn tại cạnh $e'$ có thể kết nối 2 TPLT này. Mà mọi cạnh trên $path$ đều có trọng số nhỏ hơn $e$ (như giả thiết)
⇒ Khi xoá $e$ và thay bằng $e'$, ta sẽ thu được 1 cây khung $T'$ có trọng số nhỏ hơn cây khung ban đầu
<strong>Kết luận:</strong> $T$ không phải cây khung nhỏ nhất của đồ thị.</li>
</ul>
</li>
<li>
<strong>3. Tính duy nhất</strong>:
<ul>
<li>Giả sử tồn tại 2 cây khung nhỏ nhất $T$ và $T'$. Xét cạnh $u-v$ nằm trong $T$ nhưng không trong $T'$.</li>
<li>Gọi đường đi $u \rightarrow v$ trên $T$ là $path$, trên $T'$ là $path'$. Hiển nhiên, $path'$ không chứa cạnh $u-v$.</li>
<li>Vì trọng số các cạnh của đồ thị đều khác nhau $\Rightarrow$ Cạnh lớn nhất của $path$ sẽ có trọng số lớn hơn trọng số cạnh lớn nhất của $path'$ hoặc ngược lại.
⇒ Theo tính chất đường đi hẹp nhất, $T$ hoặc $T'$ sẽ không phải là cây khung nhỏ nhất.</li>
</ul>
</li>
<li>
<strong>4. Tính chất cạnh nhỏ nhất</strong>:
<blockquote>
<p>Ta sẽ chứng minh mọi cây khung không chứa $e$ của đồ thị đều không phải là cây khung nhỏ nhất.</p>
</blockquote>
<ul>
<li>Giả sử $e$ nối 2 đỉnh $u$, $v$ của đồ thị. Gọi $T$ là 1 cây khung không chứa $e$ của đồ thị.</li>
<li>Xét cạnh $e'$ bất kỳ thuộc đường đi từ $u \rightarrow v$ trên $T$. Khi xóa $e'$ khỏi $T$, $T$ sẽ bị tách làm 2 thành phần liên thông, 1 thành phần liên thông chứa $u$, 1 phần phần liên thông chứa $v$.
⇒ Do đó, ta hoàn toàn có thể thêm cạnh $e$ (nối 2 đỉnh $u- v$) vào $T$ để kết nối 2 thành phần liên thông này, khi đó $T$ sẽ trở lại thành 1 cây khung của đồ thị.</li>
<li>Mặt khác, $e$ là cạnh có trọng số nhỏ nhất tuyệt đối của đồ thị, nên khi thay $e'$ bằng $e$ trên cây khung $T$, trọng số của $T$ sẽ giảm đi 1 lượng dương
<strong>Kết luận:</strong> $T$ ban đầu không phải là cây khung nhỏ nhất của đồ thị.</li>
</ul>
</li>
</ul>
<h2 class="editable"><a class="anchor" id="các-thuật-toán-tìm-cây-khung-nhỏ-nhất" href="#các-thuật-toán-tìm-cây-khung-nhỏ-nhất"></a>Các thuật toán tìm cây khung nhỏ nhất</h2>
<h3 class="editable"><a class="anchor" id="1-thuật-toán-kruskal" href="#1-thuật-toán-kruskal"></a>1. Thuật toán Kruskal</h3>
<p><strong>Ý tưởng thuật toán</strong>: Ban đầu mỗi đỉnh là một cây riêng biệt, ta tìm cây khung nhỏ nhất bằng cách duyệt các cạnh theo trọng số từ nhỏ đến lớn, rồi hợp nhất các cây lại với nhau.</p>
<p>Cụ thể hơn, giả sử cạnh đang xét nối 2 đỉnh $u$ và $v$, nếu 2 đỉnh này nằm ở 2 cây khác nhau thì ta thêm cạnh này vào cây khung, đồng thời hợp nhất 2 cây chứa $u$ và $v$.</p>
<p>Giả sử ta cần tìm cây khung nhỏ nhất của đồ thị $G$. Thuật toán bao gồm các bước sau:</p>
<ul>
<li>Khởi tạo rừng $F$ (tập hợp các cây), trong đó mỗi đỉnh của G tạo thành một cây riêng biệt.</li>
<li>Khởi tạo tập $S$ chứa tất cả các cạnh của $G$.</li>
<li>Chừng nào $S$ còn <strong>khác rỗng</strong> và $F$ gồm <strong>hơn một cây</strong>
<ul>
<li>Xóa cạnh nhỏ nhất trong $S$</li>
<li>Nếu cạnh đó nối hai cây khác nhau trong $F$, thì thêm nó vào $F$ và hợp hai cây kề với nó làm một</li>
<li>Nếu không thì loại bỏ cạnh đó.</li>
</ul>
</li>
</ul>
<p>Khi thuật toán kết thúc, rừng chỉ gồm đúng một cây và đó là một cây khung nhỏ nhất của đồ thị $G$</p>
<p>Ví dụ các bước giải bài toán tìm cây khung nhỏ nhất với thuật toán Kruskal :
<img src="https://i.imgur.com/ZvvusBq.gif" />
</p>
<p>Để thực hiện thao tác kiểm tra cạnh và hợp nhất 2 cây một cách nhanh chóng, ta sử dụng cấu trúc <strong><a href="https://vnoi.info/wiki/algo/data-structures/disjoint-set.md">Disjoint Set</a></strong>, dưới đây là đoạn code dùng để cài đặt thuật toán:
</p><pre class="highlight"><code><span class="cm">/*input
4 4
1 2 1
2 3 2
3 4 3
4 1 4
*/</span>
<span class="cp">#include &lt;bits/stdc++.h&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">// Cấu trúc để lưu các cạnh đồ thị</span>
<span class="c1">// u, v là 2 đỉnh, c là trọng số cạnh</span>
<span class="k">struct</span> <span class="nc">Edge</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">Edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">_u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_c</span><span class="p">)</span><span class="o">:</span> <span class="n">u</span><span class="p">(</span><span class="n">_u</span><span class="p">),</span> <span class="n">v</span><span class="p">(</span><span class="n">_v</span><span class="p">),</span> <span class="n">c</span><span class="p">(</span><span class="n">_c</span><span class="p">)</span> <span class="p">{};</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Dsu</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">par</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">par</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">par</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="n">u</span><span class="p">)</span> <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">join</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">u</span><span class="p">);</span> <span class="n">v</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">par</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="n">dsu</span><span class="p">;</span>

<span class="c1">// n và m là số đỉnh và số cạnh</span>
<span class="c1">// totalWeight là tổng trọng số các cạnh trong cây khung nhỏ nhất</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">totalWeight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">vector</span> <span class="o">&lt;</span> <span class="n">Edge</span> <span class="o">&gt;</span> <span class="n">edges</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Fast IO</span>
    <span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">c</span><span class="p">;</span>
        <span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">});</span>
    <span class="p">}</span>

    <span class="n">dsu</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

    <span class="c1">// Sắp xếp lại các cạnh theo trọng số tăng dần</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">edges</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">edges</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="n">Edge</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="n">Edge</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">.</span><span class="n">c</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="c1">// Duyệt qua các cạnh theo thứ tự đã sắp xếp</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">e</span> <span class="o">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Nếu không hợp nhất được 2 đỉnh u và v thì bỏ qua</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dsu</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">u</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">v</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>

        <span class="c1">// Nếu hợp nhất được u, v ta thêm trọng số cạnh vào kết quả</span>
        <span class="n">totalWeight</span> <span class="o">+=</span> <span class="n">e</span><span class="p">.</span><span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Xuất ra kết quả</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">totalWeight</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<h4 class="editable"><a class="anchor" id="chứng-minh-tính-đúng-đắn-của-thuật-toán" href="#chứng-minh-tính-đúng-đắn-của-thuật-toán"></a>Chứng minh tính đúng đắn của thuật toán:</h4>
<p>Ta phải chứng minh hai điều:</p>
<ol>
<li>đầu ra của thuật toán là một cây khung</li>
<li>cây đó có trọng số nhỏ nhất trong số tất cả các cây khung của đồ thị.</li>
</ol>
<p><strong>Chứng minh (1)</strong></p>
<ul>
<li>Mỗi cạnh $(u, v)$ được xét đến, nó chỉ kết nạp vào câu khung nếu $u, v$ thuộc 2 thành phần liên thông khác nhau $T_u, T_v$ ⇒ Do đó các cạnh được thêm không tạo thành chu trình</li>
<li>Do $T$ không có chu trình ⇒ số cạnh được thêm $≤ n - 1$. Ta sẽ chứng minh $T$ có đúng $n - 1$ cạnh
<ul>
<li>Giả sử số cạnh được thêm $&lt; n - 1$ ⇒ $T$ gồm hai hay nhiều thành phần liên thông</li>
<li>Mặt khác, do $G$ liên thông ⇒ tồn tại các cạnh thuộc $G$ nối các thành phần liên thông đó mà không thuộc $T$. Do đó cạnh đầu tiên nhỏ nhất trong số các cạnh này sẽ được đưa vào do nó không tạo thành chu trình, mâu thuẫn với giả thiết ở trên ⇒ Giả sử sai</li>
<li>Vậy số cạnh được thêm vào bằng đúng $n - 1$</li>
</ul>
</li>
</ul>
<p><strong>Chứng minh (2)</strong></p>
<blockquote>
<p><strong><em>Lưu ý</em></strong> : Nếu bạn mới học cây khung lần đầu tiên chưa nên đọc ngay chứng minh này, vì chúng có thể khiến bạn hoang mang. Chứng minh có sử dụng một số khái niệm như <strong><em>lát cắt</em></strong>, <strong><em>lát cắt hẹp nhất</em></strong></p>
</blockquote>
<p>Trong chứng minh này, mình có quy ước sử dụng một số kí hiệu:</p>
<ul>
<li>$|A|$ : số lượng phần tử có trong tập hợp $A$</li>
<li>$A - B$ : tập hợp các phần tử thuộc $A$ mà không thuộc $B$</li>
</ul>
<p>Giờ cùng đi vào chi tiết chứng minh nhé (づ◔ ͜ʖ◔)づ</p>
<ul>
<li>Gọi $T$ là cây khung đầu ra của thuật toán Kruskal và $T^*$ là một cây khung nhỏ nhất, ta sẽ chứng minh tổng trọng số trên $T$ và $T^*$ bằng nhau : $c(T)$ = $c(T^*)$</li>
<li>Nếu $c(T)$ = $c(T^*)$ ⇒ hiển nhiên đúng</li>
<li>Nếu $c(T)$ ≠ $c(T^*)$ gọi $(u, v)$ là cạnh $\in$ $T$ mà $\notin$ $T^*$ hay thuộc $T - T^*$. Gọi $S$ là thành phần liên thông chứa u tại thời điểm $(u, v)$ được thêm vào $T$.
<strong>Nhận xét:</strong>
Dễ thấy nếu xóa cạnh $(u, v)$ trên $T$ thì sẽ tách thành 2 <strong>thành phần liên thông</strong> $S$ và $G - S$.
Đây là một <strong>lát cắt</strong>, ta có thể thêm bất cứ cạnh nào nối giữa 2 <strong>thành phần liên thông</strong> này để tạo thành một cây mới ⇒ $(u, v)$ $\in$ lát cắt $(S, G - S)$.
<blockquote>
<p><strong>Định nghĩa :</strong> Một lát cắt $s$ - $t$ là một tập con của 𝐸 mà khi loại bỏ những cạnh này thì không còn đường đi từ $s$ tới $t$. (<a href="https://vnoi.info//wiki/translate/wcipeg/Flows#b%C3%A0i-to%C3%A1n-l%C3%A1t-c%E1%BA%AFt-h%E1%BA%B9p-nh%E1%BA%A5t-minimun-s-t-cut">Bài toán lát cắt hẹp nhất</a>)</p>
</blockquote>
<p>Ta sẽ chứng minh $(u, v)$ thuộc <strong>lát cắt nhỏ nhất</strong> $(S, G - S)$</p>
<ul>
<li>Nếu tồn tại đường đi trọng số $e$ từ $S$ đến $G - S$ có trọng số nhỏ hơn $(u, v)$, thuật toán kruskal sẽ chọn $e$ thay vì $(u, v)$ ⇒ vô lý.
⇒ <em>Ta khẳng định $(u, v)$ có <strong>trọng số nhỏ nhất</strong> trong các cạnh từ $S$ đến $(G - S)$.</em> <strong>(1)</strong>
</li>
<li>Mặt khác, bởi vì $T^*$ là 1 cây khung nhỏ nhất nên có một đường từ $S$ tới $G - S$, gọi cạnh thuộc đường này là $(x, y)$. Xét cây khung :
${T^*}' = T^* \cup (u, v) - (x, y)$ ⇒ $c({T^*}') = c(T^*) + c(u, v) - c(x, y)$</li>
<li>Do theo <strong>(1)</strong> có: $c(u, v) ≤ c(x, y)$ nên $c({T^*}') ≤ c(T^*)$ mà $T^*$ là cây khung nhỏ nhất ⇒ $c({T^*}')$ = $c(T^*)$ và ${T^*}'$ cũng là <strong>cây khung nhỏ nhất</strong> ⇒ $|T - {T^*}'|$ = $|T - T^*| - 1$
<em><strong>Ý nghĩa :</strong> Như vậy ta đã biến đổi được <strong>cây khung nhỏ nhất</strong> ${T^*}$ thành cây khung ${T^*}'$ cũng là <strong>cây khung nhỏ nhất</strong> mà làm giảm số cạnh khác nhau của $T$ và ${T^*}$ đi 1 cạnh</em>
</li>
<li>Lặp lại cách chứng minh với mỗi cạnh thuộc $T - {T^*}'$, ta sẽ biến đổi được ${T^*}'$ thành ${T}$, hay nói cách khác đã đã biến đổi cây khung nhỏ nhất ban đầu về cây khung đầu ra của Kruskal : $c(T) = c(T^*)$.</li>
</ul>
</li>
</ul>
<p><strong>Đánh giá độ phức tạp thuật toán:</strong>
Gọi $n$ là số đỉnh, $m$ là số cạnh của đồ thị</p>
<p>Thuật toán gồm 2 phần:</p>
<ul>
<li>Sắp xếp mảng $m$ cạnh theo trọng số tăng dần mất độ phức tạp $O(m \log{m})$.</li>
<li>Ta duyệt $m$ cạnh, mỗi cạnh dùng Disjoint Set mất độ phức tạp $O(\log{n})$, vậy tổng cộng mất độ phức tạp $O(m\log{n})$.</li>
</ul>
<p>$\Rightarrow$ độ phức tạp của thuật toán Kruskal là $O(m\log{m} +m\log{n})$</p>
<h3 class="editable"><a class="anchor" id="2-thuật-toán-prim" href="#2-thuật-toán-prim"></a>2. Thuật toán Prim</h3>
<p><strong>Ý tưởng thuật toán</strong>: Ý tưởng của thuật toán Prim rất giống với ý tưởng của thuật toán Dijkstra (tìm đường đi ngắn nhất trên đồ thị).
Nếu như thuật toán <strong>Kruskal</strong> xây dựng cây khung nhỏ nhất bằng cách kết nạp từng <strong>cạnh</strong> vào đồ thị thì thuật toán <strong>Prim</strong> lại kết nạp từng <strong>đỉnh</strong> vào đồ thị theo tiêu chí: đỉnh được nạp vào tiếp theo phải <strong>chưa được nạp</strong> và <strong>gần nhất</strong> với các đỉnh đã được nạp vào đồ thị.</p>
<p>Thuật toán bao gồm các bước sau:</p>
<ul>
<li>Khởi tạo tập $S$ là cây khung hiện tại, ban đầu <strong>S</strong> chưa có đỉnh nào.</li>
<li>Khởi tạo mảng $D$ trong đó $D_i$ là khoảng cách ngắn nhất từ đỉnh $i$ đến 1 đỉnh đã được kết nạp vào tập $S$, ban đầu $D[i]$ = $+\infty$</li>
<li>Lặp lại các thao tác sau $n$ lần($n$ là số cạnh của đồ thị)
<ul>
<li>Tìm đỉnh $u$ không thuộc $S$ có $D_u$ nhỏ nhất, thêm $u$ vào tập $S$.</li>
<li>Xét tất cả các đỉnh $v$ kề $u$, cập nhật $D_v = min(D_v, w_{u,v})$ với $w_{u,v}$ là trọng số cạnh $u-v$. Nếu $D_v$ được cập nhật theo $w_{u,v}$ thì đánh dấu $trace_v = u$.</li>
<li>Thêm cạnh $u-trace[u]$ vào tập cạnh thuộc cây khung nhỏ nhất.</li>
</ul>
</li>
</ul>
<p>Mặc dù không bắt buộc, các bạn có thể đọc chứng minh tính đúng đắn thuật toán của Wiki tại <a href="https://vi.wikipedia.org/wiki/Thu%E1%BA%ADt_to%C3%A1n_Prim#Ch%E1%BB%A9ng_minh">đây</a>.</p>
<p>Khi hoàn thành xong $n$ bước trên, ta thu được cây khung nhỏ nhất của đồ thị gồm $n$ đỉnh và $n - 1$ cạnh.</p>
<p>Ví dụ các bước giải bài toán tìm cây khung nhỏ nhất với thuật toán Prim:
<img src="https://i.imgur.com/E8xqn14.gif" /></p>
<p>Đoạn code sử dụng để cài đặt thuật toán Prim:
</p><pre class="highlight"><code><span class="cm">/*input
4 4
1 2 1
2 3 2
3 4 3
4 1 4
*/</span>
<span class="cp">#include "bits/stdc++.h"
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#define fi first
#define se second
</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mf">1e5</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">INF</span> <span class="o">=</span> <span class="mf">1e9</span><span class="p">;</span>

<span class="c1">// khai báo đồ thị. g[u] chứa các cạnh nối với đỉnh u. Các cạnh sẽ được lưu dưới dạng pair&lt;v,c&gt;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
<span class="n">vector</span> <span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">g</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="kt">int</span> <span class="n">dis</span><span class="p">[</span><span class="n">N</span><span class="p">];</span> <span class="c1">// mảng d lưu khoảng cách của toàn bộ đỉnh</span>

<span class="kt">int</span> <span class="nf">prim</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// thuật toán Prim bắt đầu chạy từ đỉnh nguồn s</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// Sử dụng priority_queue lưu khoảng cách của các đỉnh tăng dần đối với cây khung</span>
    <span class="c1">// Vì priority_queue.top luôn là phần tử lớn nhất, ta sẽ phải sử dụng greater&lt;pair&lt;int,int&gt;&gt;</span>
    <span class="c1">// để priority_queue.top là phần tử nhỏ nhất</span>
    <span class="c1">// các phần tử lưu trong priority queue sẽ có dạng pair&lt;dis[u],u&gt;</span>
    <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">q</span><span class="p">;</span>

    <span class="c1">// khởi tạo khoảng cách của các đỉnh là vô cùng lớn</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>

    <span class="c1">// khởi tạo đỉnh nguồn có khoảng cách là 0 và push đỉnh này vào</span>
    <span class="n">dis</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">});</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// lấy đỉnh có khoảng cách nhỏ nhất chưa được kết nạp</span>
        <span class="k">auto</span> <span class="n">top</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">curDis</span> <span class="o">=</span> <span class="n">top</span><span class="p">.</span><span class="n">fi</span><span class="p">;</span> <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">top</span><span class="p">.</span><span class="n">se</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">curDis</span> <span class="o">!=</span> <span class="n">dis</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>

        <span class="c1">// kết nạp đỉnh u vào cây khung</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="n">dis</span><span class="p">[</span><span class="n">u</span><span class="p">];</span> <span class="n">dis</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">INF</span><span class="p">;</span>

        <span class="c1">// cập nhất khoảng cách cho các đỉnh kề u</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">fi</span><span class="p">;</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">se</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dis</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dis</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">({</span> <span class="n">dis</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">v</span><span class="p">});</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">c</span><span class="p">;</span>
        <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">({</span><span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">});</span>
        <span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">push_back</span><span class="p">({</span><span class="n">u</span><span class="p">,</span> <span class="n">c</span><span class="p">});</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">prim</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span></code></pre>
Đánh giá độ phức tạp thuật toán:
<ul>
<li>Ta duyệt tổng cộng $n$ lần, mỗi lần lấy 1 đỉnh ra khỏi heap mất $O(\log{n})$ và cập nhật trọng số của tất cả các đỉnh kề với đỉnh đó, tổng số lần cập nhật là $m$ lần, mỗi lần cập nhật ta mất độ phức tạp $O(\log{n})$.</li>
<li>Như vậy, độ phức tạp của thuật toán Prim là $O((m + n)\log{n})$ với n là số đỉnh và m là số cạnh của đồ thị.</li>
</ul>
<p><strong>Fact</strong>: Trong các bài toán tìm cây khung, phần lớn mọi người sẽ sử dụng thuật toán <strong>Kruskal</strong> do tính dễ cài đặt cũng như dễ hiểu của nó.</p>
<blockquote>
<p><strong>Bonus :</strong> Các bạn có thể sử dụng <a href="https://visualgo.net/en/mst">Visualgo</a> để mô phỏng thuật toán Kruskal và Prim thông qua hoạt ảnh, qua đó hiểu thêm về các thuật toán trên</p>
</blockquote>
<h2 class="editable"><a class="anchor" id="một-số-bài-toán-áp-dụng" href="#một-số-bài-toán-áp-dụng"></a>Một số bài toán áp dụng</h2>
<h3 class="editable"><a class="anchor" id="1-bài-toán-nkcity" href="#1-bài-toán-nkcity"></a>1. Bài toán <a href="https://oj.vnoi.info/problem/nkcity">NKCITY</a>
</h3>
<h4 class="editable"><a class="anchor" id="tóm-tắt-đề-bài" href="#tóm-tắt-đề-bài"></a>Tóm tắt đề bài</h4>
<p>1 thành phố gồm $N$ trọng điểm, $M$ tuyến đường có thể được xây dựng với chi phí xây dựng khác nhau. Yêu cầu chọn ra một số tuyến đường sao cho $N$ trọng điểm phải được liên thông với nhau và chi phí xây dựng tuyến đường lớn nhất là nhỏ nhất có thể.</p>
<h4 class="editable"><a class="anchor" id="thuật-toán" href="#thuật-toán"></a>Thuật toán</h4>
<p>Dựa vào tính chất <strong>đường đi hẹp nhất</strong> của cây khung mà ta đã trình bày ở trên, đường đi giữa 2 đỉnh $u$, $v$ bất kỳ trên cây khung nhỏ nhất là đường đi có cạnh lớn nhất là nhỏ nhất của đồ thị.
Như vậy việc chọn ra các tuyến đường để xây dựng chỉ đơn giản là chọn các cạnh trên cây khung nhỏ nhất của đồ thị.</p>
<h4 class="editable"><a class="anchor" id="độ-phức-tạp" href="#độ-phức-tạp"></a>Độ phức tạp</h4>
<p>Chính là độ phức tạp của thuật toán tìm cây khung nhỏ nhất mà các bạn sẽ cài đặt.</p>
<h4 class="editable"><a class="anchor" id="cài-đặt" href="#cài-đặt"></a>Cài đặt</h4>
<p>Ở đây ta sẽ dùng Kruskal để tìm cây khung nhỏ nhất
</p><pre class="highlight"><code><span class="cm">/*input
4 4
1 2 1
2 3 2
3 4 3
4 1 4
*/</span>
<span class="cp">#include &lt;bits/stdc++.h&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">Edge</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">Edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">_u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_c</span><span class="p">)</span><span class="o">:</span> <span class="n">u</span><span class="p">(</span><span class="n">_u</span><span class="p">),</span> <span class="n">v</span><span class="p">(</span><span class="n">_v</span><span class="p">),</span> <span class="n">c</span><span class="p">(</span><span class="n">_c</span><span class="p">)</span> <span class="p">{};</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Dsu</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">par</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">par</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">par</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="n">u</span><span class="p">)</span> <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">join</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">u</span><span class="p">);</span> <span class="n">v</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">par</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="n">dsu</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">maxWeight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">vector</span> <span class="o">&lt;</span> <span class="n">Edge</span> <span class="o">&gt;</span> <span class="n">edges</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">c</span><span class="p">;</span>
        <span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">});</span>
    <span class="p">}</span>

    <span class="n">dsu</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

    <span class="n">sort</span><span class="p">(</span><span class="n">edges</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">edges</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="n">Edge</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="n">Edge</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">.</span><span class="n">c</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">e</span> <span class="o">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dsu</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">u</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">v</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">maxWeight</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxWeight</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">maxWeight</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<h3 class="editable"><a class="anchor" id="2-bài-toán-tìm-cây-khung-nhỏ-nhất-cho-mỗi-cạnh-codeforces-609e" href="#2-bài-toán-tìm-cây-khung-nhỏ-nhất-cho-mỗi-cạnh-codeforces-609e"></a>2. Bài toán <a href="https://codeforces.com/contest/609/problem/E">tìm cây khung nhỏ nhất cho mỗi cạnh - Codeforces 609E</a>
</h3>
<h4 class="editable"><a class="anchor" id="tóm-tắt-đề-bài-1" href="#tóm-tắt-đề-bài-1"></a>Tóm tắt đề bài</h4>
<p>Cho đồ thị vô hướng $G$ gồm $n$ đỉnh và $m$ cạnh. Yêu cầu với mỗi cạnh trong đồ thị, tìm cây khung nhỏ nhất <strong>chứa cạnh đó</strong> của đồ thị và in ra trọng số của cây khung đó.</p>
<p>Đây là 1 bài tập khá kinh điển về cây khung nhỏ nhất. Để giải được bài tập này, chúng ta cần giải bài LUBENICA trước. Các bạn có thể đọc thêm về bài ở <a href="lubenica-vnoj">đây</a></p>
<h4 class="editable"><a class="anchor" id="thuật-toán-1" href="#thuật-toán-1"></a>Thuật toán:</h4>
<ul>
<li>Đầu tiên, ta dựng cây khung nhỏ nhất $S$ của đồ thị ban đầu:</li>
<li>Sau đó, ta lần lượt đi tìm cây khung nhỏ nhất chứa mỗi cạnh của đồ thị. Với 1 cạnh i nối 2 đỉnh $u$, $v$ với trọng số $w$, có 2 trường hợp xảy ra:
<ul>
<li>Cạnh $u-v$ đã thuộc cây khung nhỏ nhất $S$ ban đầu, cây khung cần tìm chính là $S$.</li>
<li>Cạnh $u-v$ không thuộc cây khung nhỏ nhất $S$. Như vậy nếu thêm cạnh $u-v$ vào cây khung sẽ tạo thành chu trình từ $u\rightarrow v$. Do đó ta phải xóa đi 1 cạnh trên chu trình này để đảm bảo tính chất của cây khung. Và đương nhiên để tối ưu thì ta sẽ chọn xóa đi cạnh có <strong>trọng số lớn nhất</strong> trên đường đi từ $u \rightarrow v$ (đã được trình bày trong bài LUBENICA ở trên) và thêm cạnh $u-v$ vào cây khung sau khi đã xóa cạnh đó.</li>
</ul>
</li>
</ul>
<h4 class="editable"><a class="anchor" id="code-mẫu" href="#code-mẫu"></a>Code mẫu:</h4>
<pre class="highlight"><code><span class="cm">/*input
8 10
8 7 11
3 5 23
2 1 23
7 2 13
6 4 18
1 4 20
8 4 17
2 8 8
3 2 9
5 6 29
*/</span>
<span class="cp">#include &lt;bits/stdc++.h&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#define fi first
#define se second
#define bit(x, k) (1ll&amp;(x &gt;&gt; k))
</span>
<span class="k">using</span> <span class="n">ll</span> <span class="o">=</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mf">2e5</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">const</span> <span class="n">ll</span> <span class="n">INF</span> <span class="o">=</span> <span class="mf">1e18</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">Edge</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">id</span><span class="p">;</span>
    <span class="n">Edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">_u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_id</span><span class="p">)</span><span class="o">:</span> <span class="n">u</span><span class="p">(</span><span class="n">_u</span><span class="p">),</span> <span class="n">v</span><span class="p">(</span><span class="n">_v</span><span class="p">),</span> <span class="n">c</span><span class="p">(</span><span class="n">_c</span><span class="p">),</span> <span class="n">id</span><span class="p">(</span><span class="n">_id</span><span class="p">)</span> <span class="p">{};</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Data</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">par</span><span class="p">;</span> <span class="n">ll</span> <span class="n">maxc</span> <span class="o">=</span> <span class="o">-</span><span class="n">INF</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Dsu</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">par</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">par</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">par</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="n">u</span><span class="p">)</span> <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">join</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">u</span><span class="p">);</span> <span class="n">v</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">par</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="n">dsu</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span> <span class="n">ll</span> <span class="n">mstWeight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">h</span><span class="p">[</span><span class="n">N</span><span class="p">];</span> <span class="n">ll</span> <span class="n">res</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="n">vector</span> <span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">edges</span><span class="p">;</span>
<span class="n">vector</span> <span class="o">&lt;</span><span class="n">pair</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">g</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="n">Data</span> <span class="n">up</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="mi">21</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">0</span><span class="p">].</span><span class="n">par</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">fi</span><span class="p">;</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">se</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">].</span><span class="n">maxc</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// tìm cạnh có trọng số lớn nhất trên đường đi u, v như bài LUBENICA</span>
<span class="n">ll</span> <span class="nf">lca</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ll</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">INF</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="n">swap</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">-</span> <span class="n">h</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bit</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">maxc</span><span class="p">);</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">par</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">par</span> <span class="o">!=</span> <span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">par</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">max</span><span class="p">({</span><span class="n">ret</span><span class="p">,</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">maxc</span><span class="p">,</span> <span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">maxc</span><span class="p">});</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">par</span><span class="p">;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">par</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">max</span><span class="p">({</span><span class="n">ret</span><span class="p">,</span> <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">0</span><span class="p">].</span><span class="n">maxc</span><span class="p">,</span> <span class="n">up</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">].</span><span class="n">maxc</span><span class="p">});</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">buildMST</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">dsu</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">edges</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">edges</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="n">Edge</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="n">Edge</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">.</span><span class="n">c</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dsu</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">u</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">v</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">g</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">({</span><span class="n">e</span><span class="p">.</span><span class="n">v</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">c</span><span class="p">});</span>
        <span class="n">g</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">v</span><span class="p">].</span><span class="n">push_back</span><span class="p">({</span><span class="n">e</span><span class="p">.</span><span class="n">u</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">c</span><span class="p">});</span>
        <span class="n">res</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// đánh dấu là cạnh này thuộc cây khung nhỏ nhất</span>
        <span class="n">mstWeight</span> <span class="o">+=</span> <span class="n">e</span><span class="p">.</span><span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">buildLCA</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">dfs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">u</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">par</span> <span class="o">=</span> <span class="n">up</span><span class="p">[</span><span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">par</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">par</span><span class="p">;</span>
            <span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">maxc</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">maxc</span><span class="p">,</span> <span class="n">up</span><span class="p">[</span><span class="n">up</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">par</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">maxc</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">c</span><span class="p">;</span>
        <span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">});</span>
    <span class="p">}</span>

    <span class="c1">// dựng cây khung nhỏ nhất</span>
    <span class="n">buildMST</span><span class="p">();</span>

    <span class="c1">// dựng LCA</span>
    <span class="n">buildLCA</span><span class="p">();</span>

    <span class="c1">// tìm cây khung nhỏ nhất cho từng cạnh</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">id</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">res</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">mstWeight</span><span class="p">;</span>
        <span class="k">else</span> <span class="n">res</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">mstWeight</span> <span class="o">-</span> <span class="n">lca</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">u</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">e</span><span class="p">.</span><span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// in ra kết quả</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<h3 class="editable"><a class="anchor" id="3-bài-toán-160d-edges-in-mst" href="#3-bài-toán-160d-edges-in-mst"></a>3. Bài toán <a href="https://codeforces.com/problemset/problem/160/D">160D - Edges in MST</a>
</h3>
<h4 class="editable"><a class="anchor" id="tóm-tắt-đề-bài-2" href="#tóm-tắt-đề-bài-2"></a>Tóm tắt đề bài</h4>
<p>Cho đồ thị vô hướng có trọng số $G$ gồm $n$ đỉnh và $m$ cạnh. Yêu cầu với mỗi cạnh trong đồ thị, kiểm tra xem cạnh đó <strong>không thuộc</strong> bất kỳ cây khung nhỏ nhất nào, thuộc <strong>một số</strong> cây khung nhỏ nhất hay nằm trong <strong>mọi</strong> cây khung nhỏ nhất của đồ thị.</p>
<h4 class="editable"><a class="anchor" id="thuật-toán-2" href="#thuật-toán-2"></a>Thuật toán</h4>
<ul>
<li>Ban đầu, khởi tạo đồ thị $G'$ rỗng. Ta sẽ xét lần lượt từng nhóm các cạnh có cùng trọng số và thêm chúng vào đồ thị $G'$. Đồng thời, với mỗi cạnh ta không quan tâm nó nối 2 đỉnh nào mà chỉ quan tâm nó nối 2 <strong>TPLT</strong> nào trong đồ thị hiện tại.</li>
<li>Nhận xét rằng nếu có cạnh kết nối 2 <strong>TPLT khác nhau</strong>, các cạnh này sẽ xuất hiện trong <strong>ít nhất</strong> 1 cây khung nhỏ nhất. Ngược lại, nếu 1 cạnh nối 2 đỉnh <strong>đã liên thông</strong> từ trước thì cạnh này sẽ <strong>không thuộc</strong> bất kỳ cây khung nhỏ nhất nào.</li>
<li>Xét các nhóm cạnh có <strong>cùng trọng số</strong> mà thuộc <strong>2 thành phần liên thông khác nhau</strong>, ta dựng đồ thị $G$ mới từ các nhóm cạnh đó với các đỉnh là các thành phần liên thông.</li>
<li>
<strong>Dễ thấy</strong> : Chọn tập cạnh từ $G$ để thêm vào cây khung, tập cạnh đó phải thỏa mãn không tạo ra chu trình và không làm tăng thành phần liên thông của $G$ bởi vì :
<ul>
<li>Nếu tập cạnh chọn chứa chu trình thì đầu ra không còn là cây khung</li>
<li>Nếu tập cạnh làm tăng số lượng thành phần liên thông của $G$ thì cây khung sẽ mất tính <strong>nhỏ nhất</strong>
</li>
</ul>
</li>
<li>Vậy cạnh nằm trong <strong>mọi cây khung</strong> sẽ phải là cạnh mà nằm trong <strong>mọi tập cạnh</strong> mình chọn ở trên, nếu tập cạnh thiếu nó thì vi phạm tính <strong>nhỏ nhất</strong>.
⇒ Có nghĩa là nếu thiếu cạnh đó thì sẽ làm tăng <strong>thành phần liên thông</strong> của $G$. Vậy đó chỉ có thể là <strong>cạnh cầu</strong>.</li>
<li>Kết luận :
<ul>
<li>Các <strong>cạnh cầu</strong> sẽ nằm trong <strong>mọi</strong> cây khung nhỏ nhất của đồ thị</li>
<li>Các cạnh còn lại <strong>không phải cạnh cầu</strong> sẽ thuộc <strong>một số</strong> cây khung nhỏ nhất</li>
<li>
<strong>Xem thêm</strong> : <a href="https://vnoi.info/wiki/algo/graph-theory/Depth-First-Search-Tree.md#t%C3%ACm-c%E1%BA%A1nh-c%E1%BA%A7u">Tìm cạnh cầu</a>
</li>
</ul>
</li>
</ul>
<h4 class="editable"><a class="anchor" id="độ-phức-tạp-1" href="#độ-phức-tạp-1"></a>Độ phức tạp</h4>
<ul>
<li>Đầu tiên, ta phải sắp xếp lại các cạnh theo trọng số tăng dần mất đpt $O(m\log{m})$. Sau đó, ta phải duy trì 1 đồ thị hiện tại trong quá trình lần lượt thêm các nhóm cạnh vào đồ thị, ở đây ta sử dụng <strong>Disjoint Set</strong> để kiểm tra 2 đỉnh nối 2 TPLT nào cũng như thêm các cạnh vào đồ thị hiện tại.</li>
<li>Thuật toán <strong>Tarjan</strong> để tìm <strong>cầu</strong> có độ phức tạp $O(m + n)$ cho toàn đồ thị
⇒ Như vậy, độ phức tạp tổng của bài toán là $O(m\log{m} + m\log{n} + n)$.</li>
</ul>
<h4 class="editable"><a class="anchor" id="cài-đặt-1" href="#cài-đặt-1"></a>Cài đặt</h4>
<pre class="highlight"><code><span class="cm">/*input
4 5
1 2 101
1 3 100
2 3 2
2 4 2
3 4 1
*/</span>
<span class="cp">#include "bits/stdc++.h"
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#define fi first
#define se second
</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mf">1e5</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">EdgeType</span> <span class="p">{</span>
    <span class="n">NONE</span><span class="p">,</span> <span class="c1">// không cây nào chứa</span>
    <span class="n">ANY</span><span class="p">,</span> <span class="c1">// tất cả các cây đều chứa</span>
    <span class="n">ATL</span> <span class="c1">// ít nhất 1 cây chứa</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Edge</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">id</span><span class="p">;</span>
    <span class="n">Edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">_u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_id</span><span class="p">)</span><span class="o">:</span> <span class="n">u</span><span class="p">(</span><span class="n">_u</span><span class="p">),</span> <span class="n">v</span><span class="p">(</span><span class="n">_v</span><span class="p">),</span> <span class="n">c</span><span class="p">(</span><span class="n">_c</span><span class="p">),</span> <span class="n">id</span><span class="p">(</span><span class="n">_id</span><span class="p">)</span> <span class="p">{};</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Dsu</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">par</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">par</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">par</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="n">u</span><span class="p">)</span> <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="n">u</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">join</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">u</span><span class="p">);</span> <span class="n">v</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">par</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="n">dsu</span><span class="p">;</span>

<span class="n">vector</span> <span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">g</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">low</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">Time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
<span class="n">EdgeType</span> <span class="n">res</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="n">vector</span> <span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">edges</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">Time</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">fi</span><span class="p">;</span> <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">se</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">idx</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
            <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="n">num</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
                <span class="c1">// nếu cạnh là cầu thì mọi cây đều phải chứa</span>
                <span class="n">res</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">EdgeType</span><span class="o">::</span><span class="n">ANY</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">solve</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">pen</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// xử lý các nhóm cạnh có cùng trọng số</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pen</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>

    <span class="c1">// khởi tạo đồ thị nối các thành phần liên thông</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pen</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// sử dụng đỉnh cha trong dsu làm đỉnh đại diện cho thành phần liên thông</span>
        <span class="n">pen</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">u</span> <span class="o">=</span> <span class="n">dsu</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">pen</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">u</span><span class="p">);</span> <span class="n">pen</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">v</span> <span class="o">=</span> <span class="n">dsu</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">pen</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">v</span><span class="p">);</span>
        <span class="n">g</span><span class="p">[</span><span class="n">pen</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">u</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span> <span class="n">g</span><span class="p">[</span><span class="n">pen</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">v</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">num</span><span class="p">[</span><span class="n">pen</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="p">[</span><span class="n">pen</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">e</span> <span class="o">:</span> <span class="n">pen</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">u</span> <span class="o">==</span> <span class="n">e</span><span class="p">.</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// nếu 2 đỉnh cùng thuộc 1 thành phần liên thông</span>
            <span class="n">res</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">EdgeType</span><span class="o">::</span><span class="n">NONE</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// nếu 2 đỉnh nối 2 thành phần liên thông khác nhau lại với nhau</span>
            <span class="n">res</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">EdgeType</span><span class="o">::</span><span class="n">ATL</span><span class="p">;</span>
            <span class="c1">// thêm cạnh vào đồ thị</span>
            <span class="n">g</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">v</span><span class="p">].</span><span class="n">push_back</span><span class="p">({</span><span class="n">e</span><span class="p">.</span><span class="n">u</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">id</span><span class="p">});</span>
            <span class="n">g</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">({</span><span class="n">e</span><span class="p">.</span><span class="n">v</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">id</span><span class="p">});</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// tìm cạnh cầu</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">pen</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">u</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">// sau khi hoàn thành, ta thực hiện hợp các cạnh vào cây khung</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">pen</span><span class="p">)</span> <span class="n">dsu</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">u</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">c</span><span class="p">;</span>
        <span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">});</span>
    <span class="p">}</span>

    <span class="n">dsu</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

    <span class="n">sort</span><span class="p">(</span><span class="n">edges</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">edges</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="n">Edge</span> <span class="n">x</span><span class="p">,</span> <span class="n">Edge</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">.</span><span class="n">c</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">pen</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pen</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">pen</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">c</span> <span class="o">==</span> <span class="n">e</span><span class="p">.</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pen</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">solve</span><span class="p">(</span><span class="n">pen</span><span class="p">);</span>
            <span class="n">pen</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">};</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">pen</span><span class="p">);</span>

    <span class="c1">// in ra kết quả</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">EdgeType</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"none</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">EdgeType</span><span class="o">::</span><span class="n">ANY</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"any</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"at least one</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
<h2 class="editable"><a class="anchor" id="luyện-tập" href="#luyện-tập"></a>Luyện tập</h2>
<p>Các bạn có thể thử sức với một số bài tập sau:</p>
<ul>
<li>
<a href="https://www.spoj.com/PTIT/problems/P186SUMF/">P186SUMF</a> - <a href="https://codeforces.com/problemset/problem/959/E">959E</a>
</li>
<li><a href="https://vn.spoj.com/problems/VMST/">VMST</a></li>
<li><a href="https://codeforces.com/group/FLVn1Sc504/contest/274809/problem/B">C11WATER</a></li>
<li><a href="https://codeforces.com/group/FLVn1Sc504/contest/274809/problem/M">CHEER</a></li>
</ul>
</div>
</div>
</div>
</div>
